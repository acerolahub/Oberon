/*GENERATED BY OBNC 0.16.1*/

#include "ORS.h"
#include <obnc/Out.h>
#include <obnc/Files.h>
#include <obnc/OBNC.h>

#define OBERON_SOURCE_FILENAME "ORS.Mod"

OBNC_INTEGER ORS__ival_, ORS__slen_;

OBNC_REAL ORS__rval_;

ORS__Ident_ ORS__id_;

char ORS__str_[256];

OBNC_INTEGER ORS__errcnt_;

static char ch_;

static OBNC_INTEGER errpos_, lastSym_;

static OBNC_INTEGER k_;

static OBNC_INTEGER KWX_[10];

static struct {
	OBNC_INTEGER sym_;
	char id_[12];
} keyTab_[34];

static Files__Rider_ R_;

static void ReadNext_(void)
{
	unsigned char b_;

	Files__Read_(&R_, &Files__Rider_td, &b_);
	ch_ = OBNC_CHR(b_);
}


void ORS__Init_(Files__File_ F_, OBNC_INTEGER pos_)
{

	errpos_ = pos_;
	ORS__errcnt_ = 0;
	Files__Set_(&R_, &Files__Rider_td, F_, pos_);
	ReadNext_();
}


static int EndOfText_(void)
{
	return R_.eof_;
}


OBNC_INTEGER ORS__Pos_(void)
{
	return Files__Pos_(&R_, &Files__Rider_td) - 1;
}


static void OpenWriter_(void)
{

	Out__Open_();
}


void ORS__Mark_(const char msg_[], OBNC_INTEGER msg_len)
{
	OBNC_INTEGER p_;

	p_ = ORS__Pos_();
	if ((p_ > errpos_) && (ORS__errcnt_ < 20)) {
		Out__Ln_();
		Out__String_("  pos ", 7);
		Out__Int_(p_, 5);
		Out__String_(" (sym=", 7);
		Out__Int_(lastSym_, 3);
		Out__String_("): ", 4);
		Out__String_(msg_, msg_len);
		Out__Ln_();
	}
	OBNC_INC(ORS__errcnt_);
	errpos_ = p_ + 4;
}


void ORS__CopyId_(ORS__Ident_ ident_)
{

	OBNC_COPY_ARRAY(ORS__id_, ident_, 32);
}


static void Identifier_(OBNC_INTEGER *sym_)
{
	OBNC_INTEGER i_, k_;

	i_ = 0;
	do {
		if (i_ < 31) {
			ORS__id_[OBNC_IT(i_, 32, 112)] = ch_;
			OBNC_INC(i_);
		}
		ReadNext_();
	} while (! (((((unsigned char) ch_ < (unsigned char) '0') || (((unsigned char) ch_ > (unsigned char) '9') && ((unsigned char) ch_ < (unsigned char) 'A'))) || (((unsigned char) ch_ > (unsigned char) 'Z') && ((unsigned char) ch_ < (unsigned char) 'a'))) || ((unsigned char) ch_ > (unsigned char) 'z')));
	ORS__id_[OBNC_IT(i_, 32, 115)] = '\x00';
	if (i_ < 10) {
		k_ = KWX_[OBNC_IT(i_ - 1, 10, 116)];
		while ((OBNC_CMP(ORS__id_, 32, keyTab_[OBNC_IT(k_, 34, 117)].id_, 12) != 0) && (k_ < KWX_[OBNC_IT(i_, 10, 117)])) {
			OBNC_INC(k_);
		}
		if (k_ < KWX_[OBNC_IT(i_, 10, 118)]) {
			(*sym_) = keyTab_[OBNC_IT(k_, 34, 118)].sym_;
		}
		else {
			(*sym_) = 31;
		}
	}
	else {
		(*sym_) = 31;
	}
}


static void String_(void)
{
	OBNC_INTEGER i_;

	i_ = 0;
	ReadNext_();
	while ((! EndOfText_()) && (ch_ != '"')) {
		if ((unsigned char) ch_ >= (unsigned char) ' ') {
			if (i_ < 255) {
				ORS__str_[OBNC_IT(i_, 256, 128)] = ch_;
				OBNC_INC(i_);
			}
			else {
				ORS__Mark_("string too long", 16);
			}
		}
		ReadNext_();
	}
	ORS__str_[OBNC_IT(i_, 256, 132)] = '\x00';
	OBNC_INC(i_);
	ReadNext_();
	ORS__slen_ = i_;
}


static void HexString_(void)
{
	OBNC_INTEGER i_, m_, n_;

	i_ = 0;
	ReadNext_();
	while ((! EndOfText_()) && (ch_ != '$')) {
		while ((! EndOfText_()) && ((unsigned char) ch_ <= (unsigned char) ' ')) {
			ReadNext_();
		}
		if (((unsigned char) '0' <= (unsigned char) ch_) && ((unsigned char) ch_ <= (unsigned char) '9')) {
			m_ = OBNC_ORD((unsigned char) (ch_)) - 48;
		}
		else if (((unsigned char) 'A' <= (unsigned char) ch_) && ((unsigned char) ch_ <= (unsigned char) 'F')) {
			m_ = OBNC_ORD((unsigned char) (ch_)) - 55;
		}
		else {
			m_ = 0;
			ORS__Mark_("hexdig expected", 16);
		}
		ReadNext_();
		if (((unsigned char) '0' <= (unsigned char) ch_) && ((unsigned char) ch_ <= (unsigned char) '9')) {
			n_ = OBNC_ORD((unsigned char) (ch_)) - 48;
		}
		else if (((unsigned char) 'A' <= (unsigned char) ch_) && ((unsigned char) ch_ <= (unsigned char) 'F')) {
			n_ = OBNC_ORD((unsigned char) (ch_)) - 55;
		}
		else {
			n_ = 0;
			ORS__Mark_("hexdig expected", 16);
		}
		if (i_ < 256) {
			ORS__str_[OBNC_IT(i_, 256, 149)] = OBNC_CHR((m_ * 16) + n_);
			OBNC_INC(i_);
		}
		else {
			ORS__Mark_("string too long", 16);
		}
		ReadNext_();
	}
	ReadNext_();
	ORS__slen_ = i_;
}


static OBNC_REAL Ten_(OBNC_INTEGER e_)
{
	OBNC_REAL x_, t_;

	x_ = 1.0;
	t_ = 10.0;
	while (e_ > 0) {
		if (OBNC_ODD(e_)) {
			x_ = t_ * x_;
		}
		t_ = t_ * t_;
		e_ = OBNC_DIV(e_, 2);
	}
	return x_;
}


static void Number_(OBNC_INTEGER *sym_)
{
	OBNC_INTEGER i_, k_, e_, n_, s_, h_;
	OBNC_REAL x_;
	OBNC_INTEGER d_[16];
	int negE_, realNum_;

	ORS__ival_ = 0;
	i_ = 0;
	n_ = 0;
	k_ = 0;
	realNum_ = 0;
	do {
		if (n_ < 16) {
			d_[OBNC_IT(n_, 16, 172)] = OBNC_ORD((unsigned char) (ch_)) - 48;
			OBNC_INC(n_);
		}
		else {
			ORS__Mark_("too many digits", 16);
			n_ = 0;
		}
		ReadNext_();
	} while (! ((((unsigned char) ch_ < (unsigned char) '0') || (((unsigned char) ch_ > (unsigned char) '9') && ((unsigned char) ch_ < (unsigned char) 'A'))) || ((unsigned char) ch_ > (unsigned char) 'F')));
	if (((ch_ == 'H') || (ch_ == 'R')) || (ch_ == 'X')) {
		do {
			h_ = d_[OBNC_IT(i_, 16, 176)];
			if (h_ >= 10) {
				h_ = h_ - 7;
			}
			k_ = (k_ * 16) + h_;
			OBNC_INC(i_);
		} while (! (i_ == n_));
		if (ch_ == 'X') {
			(*sym_) = 20;
			if (k_ < 256) {
				ORS__ival_ = k_;
			}
			else {
				ORS__Mark_("illegal value", 14);
				ORS__ival_ = 0;
			}
		}
		else if (ch_ == 'R') {
			(*sym_) = 22;
			ORS__rval_ = OBNC_VAL(OBNC_REAL, k_);
		}
		else {
			(*sym_) = 21;
			ORS__ival_ = k_;
		}
		ReadNext_();
	}
	else {
		if (ch_ == '.') {
			realNum_ = 1;
			ReadNext_();
			if (ch_ == '.') {
				ch_ = '\x7f';
				realNum_ = 0;
			}
		}
		if (realNum_) {
			x_ = 0.0;
			e_ = 0;
			do {
				x_ = (x_ * 10.0) + OBNC_FLT(d_[OBNC_IT(i_, 16, 193)]);
				OBNC_INC(i_);
			} while (! (i_ == n_));
			while (((unsigned char) ch_ >= (unsigned char) '0') && ((unsigned char) ch_ <= (unsigned char) '9')) {
				x_ = (x_ * 10.0) + OBNC_FLT(OBNC_ORD((unsigned char) (ch_)) - 48);
				OBNC_DEC(e_);
				ReadNext_();
			}
			if ((ch_ == 'E') || (ch_ == 'D')) {
				ReadNext_();
				s_ = 0;
				if (ch_ == '-') {
					negE_ = 1;
					ReadNext_();
				}
				else {
					negE_ = 0;
					if (ch_ == '+') {
						ReadNext_();
					}
				}
				if (((unsigned char) ch_ >= (unsigned char) '0') && ((unsigned char) ch_ <= (unsigned char) '9')) {
					do {
						s_ = ((s_ * 10) + OBNC_ORD((unsigned char) (ch_))) - 48;
						ReadNext_();
					} while (! (((unsigned char) ch_ < (unsigned char) '0') || ((unsigned char) ch_ > (unsigned char) '9')));
					if (negE_) {
						e_ = e_ - s_;
					}
					else {
						e_ = e_ + s_;
					}
				}
				else {
					ORS__Mark_("digit?", 7);
				}
			}
			if (e_ < 0) {
				if (e_ >= -38) {
					x_ = x_ / Ten_((-e_));
				}
				else {
					x_ = 0.0;
				}
			}
			else if (e_ > 0) {
				if (e_ <= 38) {
					x_ = Ten_(e_) * x_;
				}
				else {
					x_ = 0.0;
					ORS__Mark_("too large", 10);
				}
			}
			(*sym_) = 22;
			ORS__rval_ = x_;
		}
		else {
			do {
				if (d_[OBNC_IT(i_, 16, 221)] < 10) {
					if (k_ <= (OBNC_DIV(2147483647 - d_[OBNC_IT(i_, 16, 222)], 10))) {
						k_ = (k_ * 10) + d_[OBNC_IT(i_, 16, 222)];
					}
					else {
						ORS__Mark_("too large", 10);
						k_ = 0;
					}
				}
				else {
					ORS__Mark_("bad integer", 12);
				}
				OBNC_INC(i_);
			} while (! (i_ == n_));
			(*sym_) = 21;
			ORS__ival_ = k_;
		}
	}
}


static void comment_(void)
{

	ReadNext_();
	do {
		while ((! EndOfText_()) && (ch_ != '*')) {
			if (ch_ == '(') {
				ReadNext_();
				if (ch_ == '*') {
					comment_();
				}
			}
			else {
				ReadNext_();
			}
		}
		while (ch_ == '*') {
			ReadNext_();
		}
	} while (! ((ch_ == ')') || EndOfText_()));
	if (! EndOfText_()) {
		ReadNext_();
	}
	else {
		ORS__Mark_("unterminated comment", 21);
	}
}


void ORS__Get_(OBNC_INTEGER *sym_)
{

	do {
		while ((! EndOfText_()) && ((unsigned char) ch_ <= (unsigned char) ' ')) {
			ReadNext_();
		}
		if (EndOfText_()) {
			(*sym_) = 70;
		}
		else if ((unsigned char) ch_ < (unsigned char) 'A') {
			if ((unsigned char) ch_ < (unsigned char) '0') {
				if (ch_ == '"') {
					String_();
					(*sym_) = 26;
				}
				else if (ch_ == '#') {
					ReadNext_();
					(*sym_) = 10;
				}
				else if (ch_ == '$') {
					HexString_();
					(*sym_) = 26;
				}
				else if (ch_ == '&') {
					ReadNext_();
					(*sym_) = 5;
				}
				else if (ch_ == '(') {
					ReadNext_();
					if (ch_ == '*') {
						(*sym_) = 0;
						comment_();
					}
					else {
						(*sym_) = 28;
					}
				}
				else if (ch_ == ')') {
					ReadNext_();
					(*sym_) = 44;
				}
				else if (ch_ == '*') {
					ReadNext_();
					(*sym_) = 1;
				}
				else if (ch_ == '+') {
					ReadNext_();
					(*sym_) = 6;
				}
				else if (ch_ == ',') {
					ReadNext_();
					(*sym_) = 40;
				}
				else if (ch_ == '-') {
					ReadNext_();
					(*sym_) = 7;
				}
				else if (ch_ == '.') {
					ReadNext_();
					if (ch_ == '.') {
						ReadNext_();
						(*sym_) = 43;
					}
					else {
						(*sym_) = 18;
					}
				}
				else if (ch_ == '/') {
					ReadNext_();
					(*sym_) = 2;
				}
				else {
					ReadNext_();
					(*sym_) = 0;
				}
			}
			else if ((unsigned char) ch_ < (unsigned char) ':') {
				Number_(&(*sym_));
			}
			else if (ch_ == ':') {
				ReadNext_();
				if (ch_ == '=') {
					ReadNext_();
					(*sym_) = 42;
				}
				else {
					(*sym_) = 41;
				}
			}
			else if (ch_ == ';') {
				ReadNext_();
				(*sym_) = 52;
			}
			else if (ch_ == '<') {
				ReadNext_();
				if (ch_ == '=') {
					ReadNext_();
					(*sym_) = 12;
				}
				else {
					(*sym_) = 11;
				}
			}
			else if (ch_ == '=') {
				ReadNext_();
				(*sym_) = 9;
			}
			else if (ch_ == '>') {
				ReadNext_();
				if (ch_ == '=') {
					ReadNext_();
					(*sym_) = 14;
				}
				else {
					(*sym_) = 13;
				}
			}
			else {
				ReadNext_();
				(*sym_) = 0;
			}
		}
		else if ((unsigned char) ch_ < (unsigned char) '[') {
			Identifier_(&(*sym_));
		}
		else if ((unsigned char) ch_ < (unsigned char) 'a') {
			if (ch_ == '[') {
				(*sym_) = 29;
			}
			else if (ch_ == ']') {
				(*sym_) = 45;
			}
			else if (ch_ == '^') {
				(*sym_) = 17;
			}
			else {
				(*sym_) = 0;
			}
			ReadNext_();
		}
		else if ((unsigned char) ch_ < (unsigned char) '{') {
			Identifier_(&(*sym_));
		}
		else {
			if (ch_ == '{') {
				(*sym_) = 30;
			}
			else if (ch_ == '}') {
				(*sym_) = 46;
			}
			else if (ch_ == '|') {
				(*sym_) = 54;
			}
			else if (ch_ == '~') {
				(*sym_) = 27;
			}
			else if (ch_ == '\x7f') {
				(*sym_) = 43;
			}
			else {
				(*sym_) = 0;
			}
			ReadNext_();
		}
	} while (! ((*sym_) != 0));
	lastSym_ = (*sym_);
}


static void EnterKW_(OBNC_INTEGER sym_, const char name_[], OBNC_INTEGER name_len)
{

	OBNC_AAT(name_len, 12, 303);
	OBNC_COPY_ARRAY(name_, keyTab_[OBNC_IT(k_, 34, 303)].id_, name_len);
	keyTab_[OBNC_IT(k_, 34, 303)].sym_ = sym_;
	OBNC_INC(k_);
}


void ORS__Init(void)
{
	static int initialized = 0;

	if (! initialized) {
		Out__Init();
		Files__Init();
		OpenWriter_();
		k_ = 0;
		KWX_[0] = 0;
		KWX_[1] = 0;
		EnterKW_(32, "IF", 3);
		EnterKW_(49, "DO", 3);
		EnterKW_(48, "OF", 3);
		EnterKW_(8, "OR", 3);
		EnterKW_(50, "TO", 3);
		EnterKW_(15, "IN", 3);
		EnterKW_(16, "IS", 3);
		EnterKW_(51, "BY", 3);
		KWX_[2] = k_;
		EnterKW_(53, "END", 4);
		EnterKW_(25, "NIL", 4);
		EnterKW_(65, "VAR", 4);
		EnterKW_(3, "DIV", 4);
		EnterKW_(4, "MOD", 4);
		EnterKW_(37, "FOR", 4);
		KWX_[3] = k_;
		EnterKW_(55, "ELSE", 5);
		EnterKW_(47, "THEN", 5);
		EnterKW_(24, "TRUE", 5);
		EnterKW_(64, "TYPE", 5);
		EnterKW_(36, "CASE", 5);
		KWX_[4] = k_;
		EnterKW_(56, "ELSIF", 6);
		EnterKW_(23, "FALSE", 6);
		EnterKW_(60, "ARRAY", 6);
		EnterKW_(67, "BEGIN", 6);
		EnterKW_(63, "CONST", 6);
		EnterKW_(57, "UNTIL", 6);
		EnterKW_(34, "WHILE", 6);
		KWX_[5] = k_;
		EnterKW_(61, "RECORD", 7);
		EnterKW_(35, "REPEAT", 7);
		EnterKW_(58, "RETURN", 7);
		EnterKW_(68, "IMPORT", 7);
		EnterKW_(69, "MODULE", 7);
		KWX_[6] = k_;
		EnterKW_(62, "POINTER", 8);
		KWX_[7] = k_;
		KWX_[8] = k_;
		EnterKW_(66, "PROCEDURE", 10);
		KWX_[9] = k_;
		initialized = 1;
	}
}
