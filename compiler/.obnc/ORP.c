/*GENERATED BY OBNC 0.16.1*/

#include "ORP.h"
#include <obnc/In.h>
#include <obnc/Out.h>
#include "ORS.h"
#include "ORB.h"
#include "ORG.h"
#include <obnc/OBNC.h>

#define OBERON_SOURCE_FILENAME "ORP.Mod"

const int ORP__PtrBaseDesc_id;
const int *const ORP__PtrBaseDesc_ids[1] = {&ORP__PtrBaseDesc_id};
const OBNC_Td ORP__PtrBaseDesc_td = {ORP__PtrBaseDesc_ids, 1};

static OBNC_INTEGER sym_;

static OBNC_INTEGER dc_;

static OBNC_INTEGER level_, exno_, version_;

static int newSF_;

static void (*expression_)(ORG__Item_ *x_, const OBNC_Td *x_td);

static void (*Type_)(ORB__Type_ *type_);

static void (*FormalType_)(ORB__Type_ *typ_, OBNC_INTEGER dim_);

static ORS__Ident_ modid_;

static ORP__PtrBase_ pbsList_;

static ORB__Object_ dummy_;

static void WINT_(OBNC_INTEGER x_)
{

	Out__Int_(x_, 3);
	Out__Ln_();
}


static void mm_(void)
{

	ORS__Mark_("YYYYYYY", 8);
}


static void ssym_(void)
{

	Out__Int_(sym_, 3);
	Out__Ln_();
}


static void Check_(OBNC_INTEGER s_, const char msg_[], OBNC_INTEGER msg_len)
{

	if (sym_ == s_) {
		ORS__Get_(&sym_);
	}
	else {
		ORS__Mark_(msg_, msg_len);
	}
}


static void qualident_(ORB__Object_ *obj_)
{

	(*obj_) = ORB__thisObj_();
	ORS__Get_(&sym_);
	if ((*obj_) == 0) {
		ORS__Mark_("undef", 6);
		(*obj_) = dummy_;
	}
	if ((sym_ == 18) && ((*OBNC_PT((*obj_), 49)).class_ == 8)) {
		ORS__Get_(&sym_);
		if (sym_ == 31) {
			(*obj_) = ORB__thisimport_((*obj_));
			ORS__Get_(&sym_);
			if ((*obj_) == 0) {
				ORS__Mark_("undef", 6);
				(*obj_) = dummy_;
			}
		}
		else {
			ORS__Mark_("identifier expected", 20);
			(*obj_) = dummy_;
		}
	}
}


static void CheckChar_(ORG__Item_ *x_, const OBNC_Td *x_td)
{

	if (! (((*OBNC_PT((*x_).type_, 60)).form_ == 3) || (((*OBNC_PT((*x_).type_, 60)).form_ == 11) && (ORS__slen_ == 2)))) {
		ORS__Mark_("not Char", 9);
		(*x_).type_ = ORB__charType_;
	}
}


static void CheckString_(ORG__Item_ *x_, const OBNC_Td *x_td)
{

	if (! (((*OBNC_PT((*x_).type_, 65)).form_ == 11) || (((*OBNC_PT((*x_).type_, 65)).form_ == 12) && ((*OBNC_PT((*OBNC_PT((*x_).type_, 65)).base_, 65)).form_ == 3)))) {
		ORS__Mark_("not String", 11);
		(*x_).type_ = ORB__strType_;
	}
}


static void CheckBool_(ORG__Item_ *x_, const OBNC_Td *x_td)
{

	if ((*OBNC_PT((*x_).type_, 70)).form_ != 2) {
		ORS__Mark_("not Boolean", 12);
		(*x_).type_ = ORB__boolType_;
	}
}


static void CheckInt_(ORG__Item_ *x_, const OBNC_Td *x_td)
{

	if ((*OBNC_PT((*x_).type_, 75)).form_ != 4) {
		ORS__Mark_("not Integer", 12);
		(*x_).type_ = ORB__intType_;
	}
}


static void CheckReal_(ORG__Item_ *x_, const OBNC_Td *x_td)
{

	if ((*OBNC_PT((*x_).type_, 80)).form_ != 5) {
		ORS__Mark_("not Real", 9);
		(*x_).type_ = ORB__realType_;
	}
}


static void CheckSet_(ORG__Item_ *x_, const OBNC_Td *x_td)
{

	if ((*OBNC_PT((*x_).type_, 85)).form_ != 6) {
		ORS__Mark_("not Set", 8);
		(*x_).type_ = ORB__setType_;
	}
}


static void CheckSetVal_(ORG__Item_ *x_, const OBNC_Td *x_td)
{

	if ((*OBNC_PT((*x_).type_, 90)).form_ != 4) {
		ORS__Mark_("not Int", 8);
		(*x_).type_ = ORB__setType_;
	}
	else if ((*x_).mode_ == 1) {
		if (((*x_).a_ < 0) || ((*x_).a_ >= 32)) {
			ORS__Mark_("invalid set", 12);
		}
	}
}


static void CheckConst_(ORG__Item_ *x_, const OBNC_Td *x_td)
{

	if ((*x_).mode_ != 1) {
		ORS__Mark_("not a constant", 15);
		(*x_).mode_ = 1;
	}
}


static void CheckReadOnly_(ORG__Item_ *x_, const OBNC_Td *x_td)
{

	if ((*x_).rdo_) {
		ORS__Mark_("read-only", 10);
	}
}


static void CheckExport_(int *expo_)
{

	if (sym_ == 1) {
		(*expo_) = 1;
		ORS__Get_(&sym_);
		if (level_ != 0) {
			ORS__Mark_("remove asterisk", 16);
		}
	}
	else {
		(*expo_) = 0;
	}
}


static int IsExtension_(ORB__Type_ t0_, ORB__Type_ t1_)
{
	return (t0_ == t1_) || ((t1_ != 0) && IsExtension_(t0_, (*OBNC_PT(t1_, 117)).base_));
}


static void TypeTest_(ORG__Item_ *x_, const OBNC_Td *x_td, ORB__Type_ T_, int guard_)
{
	ORB__Type_ xt_ = 0;

	xt_ = (*x_).type_;
	if (((*OBNC_PT(T_, 125)).form_ == (*OBNC_PT(xt_, 125)).form_) && (((*OBNC_PT(T_, 125)).form_ == 7) || (((*OBNC_PT(T_, 125)).form_ == 13) && ((*x_).mode_ == 3)))) {
		while ((xt_ != T_) && (xt_ != 0)) {
			xt_ = (*OBNC_PT(xt_, 126)).base_;
		}
		if (xt_ != T_) {
			xt_ = (*x_).type_;
			if ((*OBNC_PT(xt_, 128)).form_ == 7) {
				if (IsExtension_((*OBNC_PT(xt_, 129)).base_, (*OBNC_PT(T_, 129)).base_)) {
					ORG__TypeTest_(&(*x_), x_td, (*OBNC_PT(T_, 129)).base_, 0, guard_);
					(*x_).type_ = T_;
				}
				else {
					ORS__Mark_("not an extension", 17);
				}
			}
			else if (((*OBNC_PT(xt_, 132)).form_ == 13) && ((*x_).mode_ == 3)) {
				if (IsExtension_(xt_, T_)) {
					ORG__TypeTest_(&(*x_), x_td, T_, 1, guard_);
					(*x_).type_ = T_;
				}
				else {
					ORS__Mark_("not an extension", 17);
				}
			}
			else {
				ORS__Mark_("incompatible types", 19);
			}
		}
		else if (! guard_) {
			ORG__TypeTest_(&(*x_), x_td, 0, 0, 0);
		}
	}
	else {
		ORS__Mark_("type mismatch", 14);
	}
	if (! guard_) {
		(*x_).type_ = ORB__boolType_;
	}
}


static void selector_(ORG__Item_ *x_, const OBNC_Td *x_td)
{
	ORG__Item_ y_ = {0};
	ORB__Object_ obj_ = 0;
	OBNC_INTEGER L0_;

	while ((((sym_ == 29) || (sym_ == 18)) || (sym_ == 17)) || ((sym_ == 28) && (OBNC_IN((*OBNC_PT((*x_).type_, 150)).form_, 0x2080u)))) {
		if (sym_ == 29) {
			do {
				ORS__Get_(&sym_);
				L0_ = ORG__Here_();
				OBNC_PCT(expression_, 152)(&y_, &ORG__Item_td);
				if ((*OBNC_PT((*x_).type_, 153)).form_ == 12) {
					if ((y_.acc_ == (*x_).acc_) && (y_.acc_ == 1)) {
						ORG__PushAdd_(&(*x_), x_td, L0_);
					}
					CheckInt_(&y_, &ORG__Item_td);
					ORG__Index_(&(*x_), x_td, &y_, &ORG__Item_td);
					(*x_).type_ = (*OBNC_PT((*x_).type_, 155)).base_;
				}
				else {
					ORS__Mark_("not an array", 13);
				}
			} while (! (sym_ != 40));
			Check_(45, "no ]", 5);
		}
		else if (sym_ == 18) {
			ORS__Get_(&sym_);
			if (sym_ == 31) {
				if ((*OBNC_PT((*x_).type_, 162)).form_ == 7) {
					ORG__DeRef_(&(*x_), x_td);
					(*x_).type_ = (*OBNC_PT((*x_).type_, 162)).base_;
				}
				if ((*OBNC_PT((*x_).type_, 163)).form_ == 13) {
					obj_ = ORB__thisfield_((*x_).type_);
					ORS__Get_(&sym_);
					if (obj_ != 0) {
						ORG__Field_(&(*x_), x_td, obj_);
						(*x_).type_ = (*OBNC_PT(obj_, 166)).type_;
					}
					else {
						ORS__Mark_("undef", 6);
					}
				}
				else {
					ORS__Mark_("not a record", 13);
				}
			}
			else {
				ORS__Mark_("ident?", 7);
			}
		}
		else if (sym_ == 17) {
			ORS__Get_(&sym_);
			if ((*OBNC_PT((*x_).type_, 174)).form_ == 7) {
				ORG__DeRef_(&(*x_), x_td);
				(*x_).type_ = (*OBNC_PT((*x_).type_, 175)).base_;
			}
			else {
				ORS__Mark_("not a pointer", 14);
			}
		}
		else if ((sym_ == 28) && (OBNC_IN((*OBNC_PT((*x_).type_, 177)).form_, 0x2080u))) {
			ORS__Get_(&sym_);
			if (sym_ == 31) {
				qualident_(&obj_);
				if ((*OBNC_PT(obj_, 181)).class_ == 5) {
					TypeTest_(&(*x_), x_td, (*OBNC_PT(obj_, 181)).type_, 1);
				}
				else {
					ORS__Mark_("guard type expected", 20);
				}
			}
			else {
				ORS__Mark_("not an identifier", 18);
			}
			Check_(44, " ) missing", 11);
		}
	}
}


static int EqualSignatures_(ORB__Type_ t0_, ORB__Type_ t1_)
{
	ORB__Object_ p0_ = 0, p1_ = 0;
	int com_;

	com_ = 1;
	if (((*OBNC_PT(t0_, 194)).base_ == (*OBNC_PT(t1_, 194)).base_) && ((*OBNC_PT(t0_, 194)).nofpar_ == (*OBNC_PT(t1_, 194)).nofpar_)) {
		p0_ = (*OBNC_PT(t0_, 195)).dsc_;
		p1_ = (*OBNC_PT(t1_, 195)).dsc_;
		while (p0_ != 0) {
			if ((((*OBNC_PT(p0_, 197)).class_ == (*OBNC_PT(p1_, 197)).class_) && ((*OBNC_PT(p0_, 197)).rdo_ == (*OBNC_PT(p1_, 197)).rdo_)) && ((((*OBNC_PT(p0_, 198)).type_ == (*OBNC_PT(p1_, 198)).type_) || (((((*OBNC_PT((*OBNC_PT(p0_, 199)).type_, 199)).form_ == 12) && ((*OBNC_PT((*OBNC_PT(p1_, 199)).type_, 199)).form_ == 12)) && ((*OBNC_PT((*OBNC_PT(p0_, 199)).type_, 199)).len_ == (*OBNC_PT((*OBNC_PT(p1_, 199)).type_, 199)).len_)) && ((*OBNC_PT((*OBNC_PT(p0_, 199)).type_, 199)).base_ == (*OBNC_PT((*OBNC_PT(p1_, 199)).type_, 199)).base_))) || ((((*OBNC_PT((*OBNC_PT(p0_, 200)).type_, 200)).form_ == 10) && ((*OBNC_PT((*OBNC_PT(p1_, 200)).type_, 200)).form_ == 10)) && EqualSignatures_((*OBNC_PT(p0_, 200)).type_, (*OBNC_PT(p1_, 200)).type_)))) {
				p0_ = (*OBNC_PT(p0_, 201)).next_;
				p1_ = (*OBNC_PT(p1_, 202)).next_;
			}
			else {
				p0_ = 0;
				com_ = 0;
			}
		}
	}
	else {
		com_ = 0;
	}
	return com_;
}


static int CompTypes_(ORB__Type_ t0_, ORB__Type_ t1_, int varpar_)
{
	return (((t0_ == t1_) || (((((*OBNC_PT(t0_, 213)).form_ == 12) && ((*OBNC_PT(t1_, 213)).form_ == 12)) && ((*OBNC_PT(t0_, 213)).base_ == (*OBNC_PT(t1_, 213)).base_)) && ((*OBNC_PT(t0_, 213)).len_ == (*OBNC_PT(t1_, 213)).len_))) || ((((*OBNC_PT(t0_, 214)).form_ == 13) && ((*OBNC_PT(t1_, 214)).form_ == 13)) && IsExtension_(t0_, t1_))) || ((! varpar_) && ((((((*OBNC_PT(t0_, 216)).form_ == 7) && ((*OBNC_PT(t1_, 216)).form_ == 7)) && IsExtension_((*OBNC_PT(t0_, 216)).base_, (*OBNC_PT(t1_, 216)).base_)) || ((((*OBNC_PT(t0_, 217)).form_ == 10) && ((*OBNC_PT(t1_, 217)).form_ == 10)) && EqualSignatures_(t0_, t1_))) || ((OBNC_IN((*OBNC_PT(t0_, 218)).form_, 0x480u)) && ((*OBNC_PT(t1_, 218)).form_ == 8))));
}


static void Parameter_(ORB__Object_ par_)
{
	ORG__Item_ x_ = {0};
	int varpar_;

	OBNC_PCT(expression_, 223)(&x_, &ORG__Item_td);
	if (par_ != 0) {
		varpar_ = (*OBNC_PT(par_, 225)).class_ == 3;
		if (CompTypes_((*OBNC_PT(par_, 226)).type_, x_.type_, varpar_)) {
			if (! varpar_) {
				ORG__ValueParam_(&x_, &ORG__Item_td);
			}
			else {
				if (! (*OBNC_PT(par_, 229)).rdo_) {
					CheckReadOnly_(&x_, &ORG__Item_td);
				}
				ORG__VarParam_(&x_, &ORG__Item_td, (*OBNC_PT(par_, 230)).type_);
			}
		}
		else if (((((*OBNC_PT(x_.type_, 232)).form_ == 12) && ((*OBNC_PT((*OBNC_PT(par_, 232)).type_, 232)).form_ == 12)) && ((*OBNC_PT(x_.type_, 233)).base_ == (*OBNC_PT((*OBNC_PT(par_, 233)).type_, 233)).base_)) && ((*OBNC_PT((*OBNC_PT(par_, 233)).type_, 233)).len_ < 0)) {
			if (! (*OBNC_PT(par_, 234)).rdo_) {
				CheckReadOnly_(&x_, &ORG__Item_td);
			}
			ORG__OpenArrayParam_(&x_, &ORG__Item_td);
		}
		else if (((((((*OBNC_PT(x_.type_, 236)).form_ == 11) && varpar_) && (*OBNC_PT(par_, 236)).rdo_) && ((*OBNC_PT((*OBNC_PT(par_, 236)).type_, 236)).form_ == 12)) && ((*OBNC_PT((*OBNC_PT((*OBNC_PT(par_, 237)).type_, 237)).base_, 237)).form_ == 3)) && ((*OBNC_PT((*OBNC_PT(par_, 237)).type_, 237)).len_ < 0)) {
			ORG__StringParam_(&x_, &ORG__Item_td);
		}
		else if (((! varpar_) && ((*OBNC_PT((*OBNC_PT(par_, 238)).type_, 238)).form_ == 4)) && ((*OBNC_PT(x_.type_, 238)).form_ == 4)) {
			ORG__ValueParam_(&x_, &ORG__Item_td);
		}
		else if (((((*OBNC_PT(x_.type_, 239)).form_ == 11) && (x_.b_ == 2)) && ((*OBNC_PT(par_, 239)).class_ == 2)) && ((*OBNC_PT((*OBNC_PT(par_, 239)).type_, 239)).form_ == 3)) {
			ORG__StrToChar_(&x_, &ORG__Item_td);
			ORG__ValueParam_(&x_, &ORG__Item_td);
		}
		else if (((((*OBNC_PT((*OBNC_PT(par_, 241)).type_, 241)).form_ == 12) && ((*OBNC_PT((*OBNC_PT(par_, 241)).type_, 241)).base_ == ORB__byteType_)) && ((*OBNC_PT((*OBNC_PT(par_, 242)).type_, 242)).len_ >= 0)) && ((*OBNC_PT((*OBNC_PT(par_, 242)).type_, 242)).size_ == (*OBNC_PT(x_.type_, 242)).size_)) {
			ORG__VarParam_(&x_, &ORG__Item_td, (*OBNC_PT(par_, 243)).type_);
		}
		else {
			ORS__Mark_("incompatible parameters", 24);
		}
	}
}


static void ParamList_(ORG__Item_ *x_, const OBNC_Td *x_td)
{
	OBNC_INTEGER n_;
	ORB__Object_ par_ = 0;

	par_ = (*OBNC_PT((*x_).type_, 251)).dsc_;
	n_ = 0;
	if (sym_ != 44) {
		Parameter_(par_);
		n_ = 1;
		while (sym_ <= 40) {
			Check_(40, "comma?", 7);
			if (par_ != 0) {
				par_ = (*OBNC_PT(par_, 256)).next_;
			}
			OBNC_INC(n_);
			Parameter_(par_);
		}
		Check_(44, ") missing", 10);
	}
	else {
		ORS__Get_(&sym_);
	}
	if (n_ < (*OBNC_PT((*x_).type_, 262)).nofpar_) {
		ORS__Mark_("too few params", 15);
	}
	else if (n_ > (*OBNC_PT((*x_).type_, 263)).nofpar_) {
		ORS__Mark_("too many params", 16);
	}
}


static void StandFunc_(ORG__Item_ *x_, const OBNC_Td *x_td, OBNC_INTEGER fct_, ORB__Type_ restyp_)
{
	ORG__Item_ y_ = {0};
	OBNC_INTEGER n_, npar_;

	Check_(28, "no (", 5);
	npar_ = OBNC_MOD(fct_, 10);
	fct_ = OBNC_DIV(fct_, 10);
	OBNC_PCT(expression_, 270)(&(*x_), x_td);
	n_ = 1;
	while (sym_ == 40) {
		ORS__Get_(&sym_);
		OBNC_PCT(expression_, 271)(&y_, &ORG__Item_td);
		OBNC_INC(n_);
	}
	Check_(44, "no )", 5);
	if (n_ == npar_) {
		if (fct_ == 0) {
			if (OBNC_IN((*OBNC_PT((*x_).type_, 275)).form_, 0x30u)) {
				ORG__Abs_(&(*x_), x_td);
				restyp_ = (*x_).type_;
			}
			else {
				ORS__Mark_("bad type", 9);
			}
		}
		else if (fct_ == 1) {
			CheckInt_(&(*x_), x_td);
			ORG__Odd_(&(*x_), x_td);
		}
		else if (fct_ == 2) {
			CheckReal_(&(*x_), x_td);
			ORG__Floor_(&(*x_), x_td);
		}
		else if (fct_ == 3) {
			CheckInt_(&(*x_), x_td);
			ORG__Float_(&(*x_), x_td);
		}
		else if (fct_ == 4) {
			if ((*OBNC_PT((*x_).type_, 280)).form_ <= 10) {
				ORG__Ord_(&(*x_), x_td);
			}
			else if (((*OBNC_PT((*x_).type_, 281)).form_ == 11) && ((*x_).b_ == 2)) {
				ORG__StrToChar_(&(*x_), x_td);
			}
			else {
				ORS__Mark_("bad type", 9);
			}
		}
		else if (fct_ == 5) {
			CheckInt_(&(*x_), x_td);
			ORG__Ord_(&(*x_), x_td);
		}
		else if (fct_ == 6) {
			if ((*OBNC_PT((*x_).type_, 286)).form_ == 12) {
				ORG__Len_(&(*x_), x_td);
			}
			else {
				ORS__Mark_("not an array", 13);
			}
		}
		else if (OBNC_IN(fct_, 0x4380u)) {
			CheckInt_(&y_, &ORG__Item_td);
			if (OBNC_IN((*OBNC_PT((*x_).type_, 288)).form_, 0x50u)) {
				ORG__Shift_(fct_, &(*x_), x_td, &y_, &ORG__Item_td);
				restyp_ = (*x_).type_;
			}
			else {
				ORS__Mark_("bad type", 9);
			}
		}
		else if (fct_ == 11) {
			ORG__ADC_(&(*x_), x_td, &y_, &ORG__Item_td);
		}
		else if (fct_ == 12) {
			ORG__SBC_(&(*x_), x_td, &y_, &ORG__Item_td);
		}
		else if (fct_ == 13) {
			ORG__UML_(&(*x_), x_td, &y_, &ORG__Item_td);
		}
		else if (fct_ == 15) {
			CheckInt_(&(*x_), x_td);
			CheckInt_(&y_, &ORG__Item_td);
			ORG__Bit_(&(*x_), x_td, &y_, &ORG__Item_td);
		}
		else if (fct_ == 16) {
			if (((*x_).mode_ == 5) && ((*OBNC_PT((*x_).type_, 294)).size_ <= (*OBNC_PT(y_.type_, 294)).size_)) {
				restyp_ = (*x_).type_;
				OBNC_RAT(&ORG__Item_td, x_td, 294);
(*x_) = y_;
			}
			else {
				ORS__Mark_("casting not allowed", 20);
			}
		}
		else if (fct_ == 17) {
			ORG__Adr_(&(*x_), x_td);
		}
		else if (fct_ == 18) {
			if ((*x_).mode_ == 5) {
				ORG__MakeConstItem_(&(*x_), x_td, ORB__intType_, (*OBNC_PT((*x_).type_, 299)).size_);
			}
			else {
				ORS__Mark_("must be a type", 15);
			}
		}
		(*x_).type_ = restyp_;
	}
	else {
		ORS__Mark_("wrong nof params", 17);
	}
}


static void element_(ORG__Item_ *x_, const OBNC_Td *x_td)
{
	ORG__Item_ y_ = {0};

	OBNC_PCT(expression_, 310)(&(*x_), x_td);
	CheckSetVal_(&(*x_), x_td);
	if (sym_ == 43) {
		ORS__Get_(&sym_);
		OBNC_PCT(expression_, 311)(&y_, &ORG__Item_td);
		CheckSetVal_(&y_, &ORG__Item_td);
		ORG__Set_(&(*x_), x_td, &y_, &ORG__Item_td);
	}
	else {
		ORG__Singleton_(&(*x_), x_td);
	}
	(*x_).type_ = ORB__setType_;
}


static void set_(ORG__Item_ *x_, const OBNC_Td *x_td)
{
	ORG__Item_ y_ = {0};

	if (sym_ >= 32) {
		if (sym_ != 46) {
			ORS__Mark_(" } missing", 11);
		}
		ORG__MakeConstItem_(&(*x_), x_td, ORB__setType_, 0);
	}
	else {
		element_(&(*x_), x_td);
		while ((sym_ < 44) || (sym_ > 46)) {
			if (sym_ == 40) {
				ORS__Get_(&sym_);
			}
			else if (sym_ != 46) {
				ORS__Mark_("missing comma", 14);
			}
			element_(&y_, &ORG__Item_td);
			ORG__SetOp_(6, &(*x_), x_td, &y_, &ORG__Item_td);
		}
	}
}


static void factor_(ORG__Item_ *x_, const OBNC_Td *x_td)
{
	ORB__Object_ obj_ = 0;
	OBNC_INTEGER rx_;

	if ((sym_ < 20) || (sym_ > 31)) {
		ORS__Mark_("expression expected", 20);
		do {
			ORS__Get_(&sym_);
		} while (! (((sym_ >= 20) && (sym_ <= 37)) || (sym_ >= 47)));
	}
	if (sym_ == 31) {
		qualident_(&obj_);
		if ((*OBNC_PT(obj_, 341)).class_ == 7) {
			StandFunc_(&(*x_), x_td, (*OBNC_PT(obj_, 341)).val_, (*OBNC_PT(obj_, 341)).type_);
		}
		else {
			ORG__MakeItem_(&(*x_), x_td, obj_, level_);
			selector_(&(*x_), x_td);
			if (sym_ == 28) {
				ORS__Get_(&sym_);
				if (((*OBNC_PT((*x_).type_, 345)).form_ == 10) && ((*OBNC_PT((*OBNC_PT((*x_).type_, 345)).base_, 345)).form_ != 9)) {
					rx_ = ORG__Here_();
					ORG__PrepCall_(&(*x_), x_td, &rx_);
					ParamList_(&(*x_), x_td);
					ORG__Call_(&(*x_), x_td, rx_);
					(*x_).type_ = (*OBNC_PT((*x_).type_, 347)).base_;
				}
				else {
					ORS__Mark_("not a function", 15);
					ParamList_(&(*x_), x_td);
				}
			}
		}
	}
	else if (sym_ == 21) {
		ORG__MakeConstItem_(&(*x_), x_td, ORB__intType_, ORS__ival_);
		ORS__Get_(&sym_);
	}
	else if (sym_ == 22) {
		ORG__MakeRealItem_(&(*x_), x_td, ORS__rval_);
		ORS__Get_(&sym_);
	}
	else if (sym_ == 20) {
		ORG__MakeConstItem_(&(*x_), x_td, ORB__charType_, ORS__ival_);
		ORS__Get_(&sym_);
	}
	else if (sym_ == 25) {
		ORS__Get_(&sym_);
		ORG__MakeConstItem_(&(*x_), x_td, ORB__nilType_, 0);
	}
	else if (sym_ == 26) {
		ORG__MakeStringItem_(&(*x_), x_td, ORS__slen_);
		ORS__Get_(&sym_);
	}
	else if (sym_ == 28) {
		ORS__Get_(&sym_);
		OBNC_PCT(expression_, 356)(&(*x_), x_td);
		Check_(44, "no )", 5);
	}
	else if (sym_ == 30) {
		ORS__Get_(&sym_);
		set_(&(*x_), x_td);
		Check_(46, "no }", 5);
	}
	else if (sym_ == 27) {
		ORS__Get_(&sym_);
		factor_(&(*x_), x_td);
		CheckBool_(&(*x_), x_td);
		ORG__Not_(&(*x_), x_td);
	}
	else if (sym_ == 23) {
		ORS__Get_(&sym_);
		ORG__MakeConstItem_(&(*x_), x_td, ORB__boolType_, 0);
	}
	else if (sym_ == 24) {
		ORS__Get_(&sym_);
		ORG__MakeConstItem_(&(*x_), x_td, ORB__boolType_, 1);
	}
	else {
		ORS__Mark_("not a factor", 13);
		ORG__MakeConstItem_(&(*x_), x_td, ORB__intType_, 0);
	}
}


static void term_(ORG__Item_ *x_, const OBNC_Td *x_td)
{
	ORG__Item_ y_ = {0};
	OBNC_INTEGER op_, f_, L0_;
	ORG__Ptr_ Lcur_ = 0;

	factor_(&(*x_), x_td);
	f_ = (*OBNC_PT((*x_).type_, 368)).form_;
	while ((sym_ >= 1) && (sym_ <= 5)) {
		L0_ = ORG__Here_();
		op_ = sym_;
		ORS__Get_(&sym_);
		if (op_ == 1) {
			if (f_ == 4) {
				factor_(&y_, &ORG__Item_td);
				if ((y_.acc_ == (*x_).acc_) && (y_.acc_ == 1)) {
					ORG__PushAdd_(&(*x_), x_td, L0_);
				}
				CheckInt_(&y_, &ORG__Item_td);
				ORG__MulOp_(&(*x_), x_td, &y_, &ORG__Item_td);
			}
			else if (f_ == 5) {
				factor_(&y_, &ORG__Item_td);
				if ((y_.acc_ == (*x_).acc_) && (y_.acc_ == 1)) {
					ORG__PushAdd_(&(*x_), x_td, L0_);
				}
				CheckReal_(&y_, &ORG__Item_td);
				ORG__RealOp_(op_, &(*x_), x_td, &y_, &ORG__Item_td);
			}
			else if (f_ == 6) {
				factor_(&y_, &ORG__Item_td);
				CheckSet_(&y_, &ORG__Item_td);
				ORG__SetOp_(op_, &(*x_), x_td, &y_, &ORG__Item_td);
			}
			else {
				ORS__Mark_("bad type", 9);
			}
		}
		else if ((op_ == 3) || (op_ == 4)) {
			CheckInt_(&(*x_), x_td);
			factor_(&y_, &ORG__Item_td);
			CheckInt_(&y_, &ORG__Item_td);
			ORG__DivOp_(op_, &(*x_), x_td, &y_, &ORG__Item_td);
		}
		else if (op_ == 2) {
			if (f_ == 5) {
				factor_(&y_, &ORG__Item_td);
				CheckReal_(&y_, &ORG__Item_td);
				ORG__RealOp_(op_, &(*x_), x_td, &y_, &ORG__Item_td);
			}
			else if (f_ == 6) {
				factor_(&y_, &ORG__Item_td);
				CheckSet_(&y_, &ORG__Item_td);
				ORG__SetOp_(op_, &(*x_), x_td, &y_, &ORG__Item_td);
			}
			else {
				ORS__Mark_("bad type", 9);
			}
		}
		else {
			CheckBool_(&(*x_), x_td);
			ORG__And1_(&(*x_), x_td);
			y_.Lseq_ = 0;
			y_.Lnext_ = 0;
			y_.Lexit_ = 0;
			factor_(&y_, &ORG__Item_td);
			CheckBool_(&y_, &ORG__Item_td);
			ORG__And2_(&(*x_), x_td, &y_, &ORG__Item_td);
			ORG__FixList_((*x_).Lexit_);
			if (1) {
				Out__String_("LSEQ: ", 7);
				Lcur_ = (*x_).Lseq_;
				while (Lcur_ != 0) {
					Out__Int_((*OBNC_PT(Lcur_, 386)).label_, 3);
					Lcur_ = (*OBNC_PT(Lcur_, 386)).next_;
				}
				Out__Ln_();
				Out__String_("LNEXT: ", 8);
				Lcur_ = (*x_).Lnext_;
				while (Lcur_ != 0) {
					Out__Int_((*OBNC_PT(Lcur_, 387)).label_, 3);
					Lcur_ = (*OBNC_PT(Lcur_, 387)).next_;
				}
				Out__Ln_();
				Out__String_("LEXIT: ", 8);
				Lcur_ = (*x_).Lexit_;
				while (Lcur_ != 0) {
					Out__Int_((*OBNC_PT(Lcur_, 388)).label_, 3);
					Lcur_ = (*OBNC_PT(Lcur_, 388)).next_;
				}
				Out__Ln_();
			}
		}
	}
}


static void SimpleExpression_(ORG__Item_ *x_, const OBNC_Td *x_td)
{
	ORG__Item_ y_ = {0};
	OBNC_INTEGER op_, L0_;
	ORG__Ptr_ Lcur_ = 0;

	if (sym_ == 7) {
		ORS__Get_(&sym_);
		term_(&(*x_), x_td);
		if (OBNC_IN((*OBNC_PT((*x_).type_, 399)).form_, 0x70u)) {
			ORG__Neg_(&(*x_), x_td);
		}
		else {
			CheckInt_(&(*x_), x_td);
		}
	}
	else if (sym_ == 6) {
		ORS__Get_(&sym_);
		term_(&(*x_), x_td);
	}
	else {
		term_(&(*x_), x_td);
		L0_ = ORG__Here_();
	}
	while ((sym_ >= 6) && (sym_ <= 8)) {
		op_ = sym_;
		ORS__Get_(&sym_);
		if (op_ == 8) {
			ORG__Or1_(&(*x_), x_td);
			CheckBool_(&(*x_), x_td);
			y_.Lseq_ = 0;
			y_.Lnext_ = 0;
			y_.Lexit_ = 0;
			term_(&y_, &ORG__Item_td);
			CheckBool_(&y_, &ORG__Item_td);
			ORG__Or2_(&(*x_), x_td, &y_, &ORG__Item_td);
			ORG__FixList_((*x_).Lseq_);
			if (1) {
				Out__String_("LSEQ: ", 7);
				Lcur_ = (*x_).Lseq_;
				while (Lcur_ != 0) {
					Out__Int_((*OBNC_PT(Lcur_, 407)).label_, 3);
					Lcur_ = (*OBNC_PT(Lcur_, 407)).next_;
				}
				Out__Ln_();
				Out__String_("LNEXT: ", 8);
				Lcur_ = (*x_).Lnext_;
				while (Lcur_ != 0) {
					Out__Int_((*OBNC_PT(Lcur_, 408)).label_, 3);
					Lcur_ = (*OBNC_PT(Lcur_, 408)).next_;
				}
				Out__Ln_();
				Out__String_("LEXIT: ", 8);
				Lcur_ = (*x_).Lexit_;
				while (Lcur_ != 0) {
					Out__Int_((*OBNC_PT(Lcur_, 409)).label_, 3);
					Lcur_ = (*OBNC_PT(Lcur_, 409)).next_;
				}
				Out__Ln_();
			}
		}
		else if ((*OBNC_PT((*x_).type_, 411)).form_ == 4) {
			term_(&y_, &ORG__Item_td);
			if ((y_.acc_ == (*x_).acc_) && (y_.acc_ == 1)) {
				ORG__PushAdd_(&(*x_), x_td, L0_);
			}
			CheckInt_(&y_, &ORG__Item_td);
			ORG__AddOp_(op_, &(*x_), x_td, &y_, &ORG__Item_td);
		}
		else if ((*OBNC_PT((*x_).type_, 412)).form_ == 5) {
			term_(&y_, &ORG__Item_td);
			if ((y_.acc_ == (*x_).acc_) && (y_.acc_ == 1)) {
				ORG__PushAdd_(&(*x_), x_td, L0_);
			}
			CheckReal_(&y_, &ORG__Item_td);
			ORG__RealOp_(op_, &(*x_), x_td, &y_, &ORG__Item_td);
		}
		else {
			CheckSet_(&(*x_), x_td);
			term_(&y_, &ORG__Item_td);
			if ((y_.acc_ == (*x_).acc_) && (y_.acc_ == 1)) {
				ORG__PushAdd_(&(*x_), x_td, L0_);
			}
			CheckSet_(&y_, &ORG__Item_td);
			ORG__SetOp_(op_, &(*x_), x_td, &y_, &ORG__Item_td);
		}
	}
}


static void expression0_(ORG__Item_ *x_, const OBNC_Td *x_td)
{
	ORG__Item_ y_ = {0};
	ORB__Object_ obj_ = 0;
	OBNC_INTEGER rel_, xf_, yf_, L0_;

	SimpleExpression_(&(*x_), x_td);
	if ((sym_ >= 9) && (sym_ <= 14)) {
		rel_ = sym_;
		ORS__Get_(&sym_);
		L0_ = ORG__Here_();
		SimpleExpression_(&y_, &ORG__Item_td);
		if ((y_.acc_ == (*x_).acc_) && (y_.acc_ == 1)) {
			ORG__PushAdd_(&(*x_), x_td, L0_);
		}
		xf_ = (*OBNC_PT((*x_).type_, 422)).form_;
		yf_ = (*OBNC_PT(y_.type_, 422)).form_;
		if (((*x_).type_ == y_.type_) || ((xf_ == 6) && (yf_ == 4))) {
			if (OBNC_IN(xf_, 0x38u)) {
				ORG__IntRealRelation_(rel_, &(*x_), x_td, &y_, &ORG__Item_td);
			}
			else if (OBNC_IN(xf_, 0x5C4u)) {
				if (rel_ <= 10) {
					ORG__IntRealRelation_(rel_, &(*x_), x_td, &y_, &ORG__Item_td);
				}
				else {
					ORS__Mark_("only = or #", 12);
				}
			}
			else if (((xf_ == 12) && ((*OBNC_PT((*OBNC_PT((*x_).type_, 427)).base_, 427)).form_ == 3)) || (xf_ == 11)) {
				ORG__StringRelation_(rel_, &(*x_), x_td, &y_, &ORG__Item_td);
			}
			else {
				ORS__Mark_("illegal comparison", 19);
			}
		}
		else if (((OBNC_IN(xf_, 0x480u)) && (yf_ == 8)) || ((OBNC_IN(yf_, 0x480u)) && (xf_ == 8))) {
			if (rel_ <= 10) {
				ORG__IntRealRelation_(rel_, &(*x_), x_td, &y_, &ORG__Item_td);
			}
			else {
				ORS__Mark_("only = or #", 12);
			}
		}
		else if ((((xf_ == 7) && (yf_ == 7)) && (IsExtension_((*OBNC_PT((*x_).type_, 435)).base_, (*OBNC_PT(y_.type_, 435)).base_) || IsExtension_((*OBNC_PT(y_.type_, 435)).base_, (*OBNC_PT((*x_).type_, 435)).base_))) || (((xf_ == 10) && (yf_ == 10)) && EqualSignatures_((*x_).type_, y_.type_))) {
			if (rel_ <= 10) {
				ORG__IntRealRelation_(rel_, &(*x_), x_td, &y_, &ORG__Item_td);
			}
			else {
				ORS__Mark_("only = or #", 12);
			}
		}
		else if ((((xf_ == 12) && ((*OBNC_PT((*OBNC_PT((*x_).type_, 438)).base_, 438)).form_ == 3)) && ((yf_ == 11) || ((yf_ == 12) && ((*OBNC_PT((*OBNC_PT(y_.type_, 439)).base_, 439)).form_ == 3)))) || (((yf_ == 12) && ((*OBNC_PT((*OBNC_PT(y_.type_, 440)).base_, 440)).form_ == 3)) && (xf_ == 11))) {
			ORG__StringRelation_(rel_, &(*x_), x_td, &y_, &ORG__Item_td);
		}
		else if (((xf_ == 3) && (yf_ == 11)) && (y_.b_ == 2)) {
			ORG__StrToChar_(&y_, &ORG__Item_td);
			ORG__IntRealRelation_(rel_, &(*x_), x_td, &y_, &ORG__Item_td);
		}
		else if (((yf_ == 3) && (xf_ == 11)) && ((*x_).b_ == 2)) {
			ORG__StrToChar_(&(*x_), x_td);
			ORG__IntRealRelation_(rel_, &(*x_), x_td, &y_, &ORG__Item_td);
		}
		else if ((xf_ == 4) && (yf_ == 4)) {
			ORG__IntRealRelation_(rel_, &(*x_), x_td, &y_, &ORG__Item_td);
		}
		else {
			ORS__Mark_("illegal comparison", 19);
		}
		(*x_).type_ = ORB__boolType_;
	}
	else if (sym_ == 15) {
		ORS__Get_(&sym_);
		CheckInt_(&(*x_), x_td);
		SimpleExpression_(&y_, &ORG__Item_td);
		CheckSet_(&y_, &ORG__Item_td);
		ORG__In_(&(*x_), x_td, &y_, &ORG__Item_td);
		(*x_).type_ = ORB__boolType_;
	}
	else if (sym_ == 16) {
		ORS__Get_(&sym_);
		qualident_(&obj_);
		TypeTest_(&(*x_), x_td, (*OBNC_PT(obj_, 454)).type_, 0);
		(*x_).type_ = ORB__boolType_;
	}
}


static void StandProc_(OBNC_INTEGER pno_)
{
	OBNC_INTEGER nap_, npar_, L0_, tmp_;
	ORG__Item_ x_ = {0}, y_ = {0}, z_ = {0};
	ORG__SYSTEMCALLS_ syscalls_ = {0};

	nap_ = 0;
	npar_ = OBNC_MOD(pno_, 10);
	if (npar_ != 0) {
		Check_(28, "no (", 5);
		OBNC_PCT(expression_, 470)(&x_, &ORG__Item_td);
		L0_ = ORG__Here_();
		nap_ = 1;
	}
	pno_ = OBNC_DIV(pno_, 10);
	if ((OBNC_IN(npar_, 0x6u)) && (pno_ < 13)) {
		if (sym_ == 40) {
			ORS__Get_(&sym_);
			OBNC_PCT(expression_, 475)(&y_, &ORG__Item_td);
			tmp_ = y_.acc_;
			ORG__loadacc_(&y_, &ORG__Item_td, 2);
			if ((x_.acc_ == 1) && (tmp_ == 1)) {
				ORG__PushAdd_(&x_, &ORG__Item_td, L0_);
			}
			nap_ = 2;
			z_.type_ = ORB__noType_;
		}
		else {
			y_.type_ = ORB__noType_;
		}
		if (sym_ == 40) {
			ORS__Mark_("wrong nof parameters", 21);
		}
	}
	else if (npar_ != 0) {
		ORG__Push_(&x_, &ORG__Item_td);
		syscalls_.ops_[OBNC_IT(nap_ - 1, 6, 484)] = x_;
		if ((sym_ != 40) && (npar_ != nap_)) {
			ORS__Mark_("wrong nof parameters", 21);
		}
		while (sym_ == 40) {
			ORS__Get_(&sym_);
			OBNC_PCT(expression_, 487)(&z_, &ORG__Item_td);
			OBNC_INC(nap_);
			ORG__Push_(&z_, &ORG__Item_td);
			syscalls_.ops_[OBNC_IT(nap_ - 1, 6, 488)] = z_;
		}
		syscalls_.ops_[OBNC_IT(nap_, 6, 490)].type_ = ORB__noType_;
	}
	if (npar_ != 0) {
		Check_(44, "no )", 5);
	}
	if ((npar_ == nap_) || (OBNC_IN(pno_, 0x50003u))) {
		if (OBNC_IN(pno_, 0x3u)) {
			CheckInt_(&x_, &ORG__Item_td);
			CheckReadOnly_(&x_, &ORG__Item_td);
			if (y_.type_ != ORB__noType_) {
				CheckInt_(&y_, &ORG__Item_td);
			}
			ORG__Increment_(pno_, &x_, &ORG__Item_td, &y_, &ORG__Item_td);
		}
		else if (OBNC_IN(pno_, 0xCu)) {
			CheckSet_(&x_, &ORG__Item_td);
			CheckReadOnly_(&x_, &ORG__Item_td);
			CheckInt_(&y_, &ORG__Item_td);
			ORG__Include_((pno_ - 2), &x_, &ORG__Item_td, &y_, &ORG__Item_td);
		}
		else if (pno_ == 4) {
			CheckBool_(&x_, &ORG__Item_td);
			ORG__Assert_(&x_, &ORG__Item_td);
		}
		else if (pno_ == 5) {
			CheckReadOnly_(&x_, &ORG__Item_td);
			if (((*OBNC_PT(x_.type_, 502)).form_ == 7) && ((*OBNC_PT((*OBNC_PT(x_.type_, 502)).base_, 502)).form_ == 13)) {
				ORG__New_(&x_, &ORG__Item_td);
			}
			else {
				ORS__Mark_("not a pointer to record", 24);
			}
		}
		else if (pno_ == 6) {
			CheckReal_(&x_, &ORG__Item_td);
			CheckInt_(&y_, &ORG__Item_td);
			CheckReadOnly_(&x_, &ORG__Item_td);
			ORG__Pack_(&x_, &ORG__Item_td, &y_, &ORG__Item_td);
		}
		else if (pno_ == 7) {
			CheckReal_(&x_, &ORG__Item_td);
			CheckInt_(&y_, &ORG__Item_td);
			CheckReadOnly_(&x_, &ORG__Item_td);
			ORG__Unpk_(&x_, &ORG__Item_td, &y_, &ORG__Item_td);
		}
		else if (pno_ == 10) {
			CheckInt_(&x_, &ORG__Item_td);
			ORG__Get_(&x_, &ORG__Item_td, &y_, &ORG__Item_td);
		}
		else if (pno_ == 11) {
			CheckInt_(&x_, &ORG__Item_td);
			ORG__Put_(&x_, &ORG__Item_td, &y_, &ORG__Item_td);
		}
		else if (pno_ == 12) {
			CheckInt_(&syscalls_.ops_[0], &ORG__Item_td);
			CheckInt_(&syscalls_.ops_[1], &ORG__Item_td);
			CheckInt_(&syscalls_.ops_[2], &ORG__Item_td);
			ORG__Copy_();
		}
		else if (pno_ == 13) {
			CheckChar_(&syscalls_.ops_[0], &ORG__Item_td);
			ORG__SysCall_(1);
		}
		else if (pno_ == 14) {
			CheckString_(&syscalls_.ops_[0], &ORG__Item_td);
			ORG__SysCall_(2);
		}
		else if (pno_ == 15) {
			CheckString_(&syscalls_.ops_[0], &ORG__Item_td);
			ORG__SysCall_(3);
		}
		else if (pno_ == 16) {
			CheckInt_(&syscalls_.ops_[0], &ORG__Item_td);
			if (syscalls_.ops_[1].type_ != ORB__noType_) {
				CheckInt_(&syscalls_.ops_[1], &ORG__Item_td);
				ORG__SysCall_(5);
			}
			else {
				ORG__SysCall_(4);
			}
		}
		else if (pno_ == 17) {
			CheckInt_(&syscalls_.ops_[0], &ORG__Item_td);
			ORG__SysCall_(6);
		}
		else if (pno_ == 18) {
			CheckReal_(&syscalls_.ops_[0], &ORG__Item_td);
			if (syscalls_.ops_[1].type_ != ORB__noType_) {
				CheckInt_(&syscalls_.ops_[1], &ORG__Item_td);
				ORG__SysCall_(8);
			}
			else {
				ORG__SysCall_(7);
			}
		}
		else if (pno_ == 19) {
			ORG__SysCall_(9);
		}
		else {
			ORS__Mark_("wrong nof parameters", 21);
		}
	}
}


static void StatSequence_(void);

static void StatSequence_TypeCase_Local(ORB__Object_ obj_, ORG__Item_ *x_, const OBNC_Td *x_td)
{
	ORB__Object_ typobj_ = 0;
}


static void StatSequence_SkipCase_Local(void)
{

	while (sym_ != 41) {
		ORS__Get_(&sym_);
	}
	ORS__Get_(&sym_);
	StatSequence_();
}


static void StatSequence_(void)
{
	ORB__Object_ obj_ = 0;
	ORB__Type_ orgtype_ = 0;
	ORG__Item_ x_ = {0}, y_ = {0}, z_ = {0}, w_ = {0};
	OBNC_INTEGER L0_, rx_, Ldeb_;
	ORG__Ptr_ Ljump_ = 0;

	do {
		obj_ = 0;
		if (! (((sym_ >= 31) && (sym_ <= 37)) || (sym_ >= 52))) {
			ORS__Mark_("statement expected", 19);
			do {
				ORS__Get_(&sym_);
			} while (! (sym_ >= 31));
		}
		if (sym_ == 31) {
			qualident_(&obj_);
			ORG__MakeItem_(&x_, &ORG__Item_td, obj_, level_);
			if (x_.mode_ == 6) {
				StandProc_((*OBNC_PT(obj_, 562)).val_);
			}
			else {
				selector_(&x_, &ORG__Item_td);
				if (sym_ == 42) {
					ORS__Get_(&sym_);
					CheckReadOnly_(&x_, &ORG__Item_td);
					L0_ = ORG__Here_();
					OBNC_PCT(expression_, 565)(&y_, &ORG__Item_td);
					if ((y_.acc_ == x_.acc_) && (x_.acc_ == 1)) {
						ORG__PushAdd_(&x_, &ORG__Item_td, L0_);
						ORG__loadacc_(&y_, &ORG__Item_td, 2);
						ORG__Pop_(&x_, &ORG__Item_td, 1);
					}
					if (CompTypes_(x_.type_, y_.type_, 0)) {
						if (((*OBNC_PT(x_.type_, 568)).form_ <= 7) || ((*OBNC_PT(x_.type_, 568)).form_ == 10)) {
							ORG__Store_(&x_, &ORG__Item_td, &y_, &ORG__Item_td);
						}
						else {
							ORG__StoreStruct_(&x_, &ORG__Item_td, &y_, &ORG__Item_td);
						}
					}
					else if (((((*OBNC_PT(x_.type_, 577)).form_ == 12) && ((*OBNC_PT(y_.type_, 577)).form_ == 12)) && ((*OBNC_PT(x_.type_, 577)).base_ == (*OBNC_PT(y_.type_, 577)).base_)) && ((*OBNC_PT(y_.type_, 577)).len_ < 0)) {
						ORG__StoreStruct_(&x_, &ORG__Item_td, &y_, &ORG__Item_td);
					}
					else if ((((*OBNC_PT(x_.type_, 579)).form_ == 12) && ((*OBNC_PT((*OBNC_PT(x_.type_, 579)).base_, 579)).form_ == 3)) && ((*OBNC_PT(y_.type_, 579)).form_ == 11)) {
						ORG__CopyString_(&x_, &ORG__Item_td, &y_, &ORG__Item_td);
					}
					else if (((*OBNC_PT(x_.type_, 581)).form_ == 4) && ((*OBNC_PT(y_.type_, 581)).form_ == 4)) {
						ORG__Store_(&x_, &ORG__Item_td, &y_, &ORG__Item_td);
					}
					else if ((((*OBNC_PT(x_.type_, 582)).form_ == 3) && ((*OBNC_PT(y_.type_, 582)).form_ == 11)) && (y_.b_ == 2)) {
						ORG__StrToChar_(&y_, &ORG__Item_td);
						ORG__Store_(&x_, &ORG__Item_td, &y_, &ORG__Item_td);
					}
					else {
						ORS__Mark_("illegal assignment", 19);
					}
				}
				else if (sym_ == 9) {
					ORS__Mark_("should be :=", 13);
					ORS__Get_(&sym_);
					OBNC_PCT(expression_, 587)(&y_, &ORG__Item_td);
				}
				else if (sym_ == 28) {
					ORS__Get_(&sym_);
					if (((*OBNC_PT(x_.type_, 589)).form_ == 10) && ((*OBNC_PT((*OBNC_PT(x_.type_, 589)).base_, 589)).form_ == 9)) {
						ORG__PrepCall_(&x_, &ORG__Item_td, &rx_);
						L0_ = ORG__Here_();
						ParamList_(&x_, &ORG__Item_td);
						ORG__Call_(&x_, &ORG__Item_td, L0_);
					}
					else {
						ORS__Mark_("not a procedure", 16);
						ParamList_(&x_, &ORG__Item_td);
					}
				}
				else if ((*OBNC_PT(x_.type_, 593)).form_ == 10) {
					if ((*OBNC_PT(x_.type_, 594)).nofpar_ > 0) {
						ORS__Mark_("missing parameters", 19);
					}
					if ((*OBNC_PT((*OBNC_PT(x_.type_, 595)).base_, 595)).form_ == 9) {
						rx_ = ORG__Here_();
						ORG__PrepCall_(&x_, &ORG__Item_td, &rx_);
						ORG__Call_(&x_, &ORG__Item_td, rx_);
					}
					else {
						ORS__Mark_("not a procedure", 16);
					}
				}
				else if (x_.mode_ == 5) {
					ORS__Mark_("illegal assignment", 19);
				}
				else {
					ORS__Mark_("not a procedure", 16);
				}
			}
		}
		else if (sym_ == 32) {
			ORS__Get_(&sym_);
			OBNC_PCT(expression_, 601)(&x_, &ORG__Item_td);
			CheckBool_(&x_, &ORG__Item_td);
			Check_(47, "no THEN", 8);
			L0_ = ORG__Here_() - 1;
			ORG__FixIf_(&L0_);
			ORG__AddPtr_(&x_.Lexit_, L0_);
			ORG__FixList_(x_.Lseq_);
			StatSequence_();
			while (sym_ == 56) {
				ORG__JumpExit_();
				ORG__AddPtr_(&Ljump_, (ORG__Here_() - 1));
				ORG__FixList_(x_.Lexit_);
				x_.Lexit_ = 0;
				x_.Lnext_ = 0;
				x_.Lseq_ = 0;
				ORS__Get_(&sym_);
				OBNC_PCT(expression_, 611)(&x_, &ORG__Item_td);
				CheckBool_(&x_, &ORG__Item_td);
				Check_(47, "no THEN", 8);
				L0_ = ORG__Here_() - 1;
				ORG__FixIf_(&L0_);
				ORG__AddPtr_(&x_.Lexit_, L0_);
				ORG__FixList_(x_.Lseq_);
				StatSequence_();
			}
			if (sym_ == 55) {
				ORG__JumpExit_();
				ORG__AddPtr_(&Ljump_, (ORG__Here_() - 1));
				ORS__Get_(&sym_);
				ORG__FixList_(x_.Lexit_);
				StatSequence_();
			}
			else {
				ORG__FixList_(x_.Lexit_);
				x_.Lexit_ = 0;
			}
			ORG__FixList_(Ljump_);
			Check_(53, "no END", 7);
			x_.Lexit_ = 0;
			x_.Lnext_ = 0;
			x_.Lseq_ = 0;
			Ljump_ = 0;
		}
		else if (sym_ == 34) {
			ORS__Get_(&sym_);
			Ldeb_ = ORG__Here_();
			OBNC_PCT(expression_, 631)(&x_, &ORG__Item_td);
			CheckBool_(&x_, &ORG__Item_td);
			Check_(49, "no DO", 6);
			L0_ = ORG__Here_() - 1;
			ORG__FixIf_(&L0_);
			ORG__AddPtr_(&x_.Lexit_, L0_);
			ORG__FixList_(x_.Lseq_);
			StatSequence_();
			while (sym_ == 56) {
				ORG__JumpWhile_(Ldeb_);
				ORG__FixList_(x_.Lexit_);
				x_.Lexit_ = 0;
				x_.Lnext_ = 0;
				x_.Lseq_ = 0;
				ORS__Get_(&sym_);
				OBNC_PCT(expression_, 641)(&x_, &ORG__Item_td);
				CheckBool_(&x_, &ORG__Item_td);
				Check_(49, "no DO", 6);
				L0_ = ORG__Here_() - 1;
				ORG__FixIf_(&L0_);
				ORG__AddPtr_(&x_.Lexit_, L0_);
				ORG__FixList_(x_.Lseq_);
				StatSequence_();
			}
			ORG__JumpWhile_(Ldeb_);
			ORG__FixList_(x_.Lexit_);
			Check_(53, "no END", 7);
			x_.Lexit_ = 0;
			x_.Lnext_ = 0;
			x_.Lseq_ = 0;
		}
		else if (sym_ == 35) {
			ORS__Get_(&sym_);
			Ldeb_ = ORG__Here_();
			StatSequence_();
			if (sym_ == 57) {
				ORS__Get_(&sym_);
				OBNC_PCT(expression_, 655)(&x_, &ORG__Item_td);
				CheckBool_(&x_, &ORG__Item_td);
				L0_ = ORG__Here_() - 1;
				ORG__FixIf_(&L0_);
				ORG__AddPtr_(&x_.Lexit_, L0_);
				ORG__FixList_(x_.Lseq_);
				ORG__JumpRepeat_(x_.Lexit_, Ldeb_);
			}
			else {
				ORS__Mark_("missing UNTIL", 14);
			}
			x_.Lexit_ = 0;
			x_.Lnext_ = 0;
			x_.Lseq_ = 0;
		}
		else if (sym_ == 37) {
			ORS__Get_(&sym_);
			if (sym_ == 31) {
				qualident_(&obj_);
				ORG__MakeItem_(&x_, &ORG__Item_td, obj_, level_);
				CheckInt_(&x_, &ORG__Item_td);
				CheckReadOnly_(&x_, &ORG__Item_td);
				if (sym_ == 42) {
					ORS__Get_(&sym_);
					OBNC_PCT(expression_, 668)(&y_, &ORG__Item_td);
					CheckInt_(&y_, &ORG__Item_td);
					ORG__For0_(&x_, &ORG__Item_td, &y_, &ORG__Item_td);
					L0_ = ORG__Here_();
					Check_(50, "no TO", 6);
					OBNC_PCT(expression_, 669)(&z_, &ORG__Item_td);
					CheckInt_(&z_, &ORG__Item_td);
					(*OBNC_PT(obj_, 669)).rdo_ = 1;
					if (sym_ == 51) {
						ORS__Get_(&sym_);
						OBNC_PCT(expression_, 670)(&w_, &ORG__Item_td);
						CheckConst_(&w_, &ORG__Item_td);
						CheckInt_(&w_, &ORG__Item_td);
					}
					else {
						ORG__MakeConstItem_(&w_, &ORG__Item_td, ORB__intType_, 1);
					}
					Check_(49, "no DO", 6);
					ORG__For1_(&x_, &ORG__Item_td, &z_, &ORG__Item_td);
					StatSequence_();
					Check_(53, "no END", 7);
					ORG__For2_(&x_, &ORG__Item_td, &w_, &ORG__Item_td);
					ORG__JumpWhile_(L0_);
					ORG__FixList_(x_.Lexit_);
					(*OBNC_PT(obj_, 675)).rdo_ = 0;
				}
				else {
					ORS__Mark_(":= expected", 12);
				}
			}
			else {
				ORS__Mark_("identifier expected", 20);
			}
		}
		else if (sym_ == 36) {
		}
		if (sym_ == 52) {
			ORS__Get_(&sym_);
			Out__Ln_();
		}
		else if (sym_ < 52) {
			ORS__Mark_("missing semicolon?", 19);
		}
	} while (! (sym_ > 52));
}


static void IdentList_(OBNC_INTEGER class_, ORB__Object_ *first_)
{
	ORB__Object_ obj_ = 0;

	if (sym_ == 31) {
		ORB__NewObj_(&(*first_), ORS__id_, class_);
		ORS__Get_(&sym_);
		CheckExport_(&(*OBNC_PT((*first_), 713)).expo_);
		while (sym_ == 40) {
			ORS__Get_(&sym_);
			if (sym_ == 31) {
				ORB__NewObj_(&obj_, ORS__id_, class_);
				ORS__Get_(&sym_);
				CheckExport_(&(*OBNC_PT(obj_, 716)).expo_);
			}
			else {
				ORS__Mark_("ident?", 7);
			}
		}
		if (sym_ == 41) {
			ORS__Get_(&sym_);
		}
		else {
			ORS__Mark_(":?", 3);
		}
	}
	else {
		(*first_) = 0;
	}
}


static void ArrayType_(ORB__Type_ *type_)
{
	ORG__Item_ x_ = {0};
	ORB__Type_ typ_ = 0;
	OBNC_INTEGER len_;

	OBNC_NEW(typ_, &ORB__TypeDesc_td, struct ORB__TypeDesc_Heap, OBNC_REGULAR_ALLOC);
	(*OBNC_PT(typ_, 727)).form_ = 9;
	OBNC_PCT(expression_, 728)(&x_, &ORG__Item_td);
	if (((x_.mode_ == 1) && ((*OBNC_PT(x_.type_, 729)).form_ == 4)) && (x_.a_ >= 0)) {
		len_ = x_.a_;
	}
	else {
		len_ = 1;
		ORS__Mark_("not a valid length", 19);
	}
	if (sym_ == 48) {
		ORS__Get_(&sym_);
		OBNC_PCT(Type_, 732)(&(*OBNC_PT(typ_, 732)).base_);
		if (((*OBNC_PT((*OBNC_PT(typ_, 733)).base_, 733)).form_ == 12) && ((*OBNC_PT((*OBNC_PT(typ_, 733)).base_, 733)).len_ < 0)) {
			ORS__Mark_("dyn array not allowed", 22);
		}
	}
	else if (sym_ == 40) {
		ORS__Get_(&sym_);
		ArrayType_(&(*OBNC_PT(typ_, 734)).base_);
	}
	else {
		ORS__Mark_("missing OF", 11);
		(*OBNC_PT(typ_, 735)).base_ = ORB__intType_;
	}
	(*OBNC_PT(typ_, 737)).size_ = (OBNC_DIV((len_ * (*OBNC_PT((*OBNC_PT(typ_, 737)).base_, 737)).size_) + 3, 4)) * 4;
	(*OBNC_PT(typ_, 738)).form_ = 12;
	(*OBNC_PT(typ_, 738)).len_ = len_;
	(*type_) = typ_;
}


static void RecordType_(ORB__Type_ *type_)
{
	ORB__Object_ obj_ = 0, obj0_ = 0, new_ = 0, bot_ = 0, base_ = 0;
	ORB__Type_ typ_ = 0, tp_ = 0;
	OBNC_INTEGER offset_, off_, n_;

	OBNC_NEW(typ_, &ORB__TypeDesc_td, struct ORB__TypeDesc_Heap, OBNC_REGULAR_ALLOC);
	(*OBNC_PT(typ_, 745)).form_ = 9;
	(*OBNC_PT(typ_, 745)).base_ = 0;
	(*OBNC_PT(typ_, 745)).mno_ = -level_;
	(*OBNC_PT(typ_, 745)).nofpar_ = 0;
	offset_ = 0;
	bot_ = 0;
	if (sym_ == 28) {
		ORS__Get_(&sym_);
		if (level_ != 0) {
			ORS__Mark_("extension of local types not implemented", 41);
		}
		if (sym_ == 31) {
			qualident_(&base_);
			if ((*OBNC_PT(base_, 751)).class_ == 5) {
				if ((*OBNC_PT((*OBNC_PT(base_, 752)).type_, 752)).form_ == 13) {
					(*OBNC_PT(typ_, 752)).base_ = (*OBNC_PT(base_, 753)).type_;
				}
				else {
					(*OBNC_PT(typ_, 753)).base_ = ORB__intType_;
					ORS__Mark_("invalid extension", 18);
				}
				(*OBNC_PT(typ_, 755)).nofpar_ = (*OBNC_PT((*OBNC_PT(typ_, 755)).base_, 755)).nofpar_ + 1;
				bot_ = (*OBNC_PT((*OBNC_PT(typ_, 756)).base_, 756)).dsc_;
				offset_ = (*OBNC_PT((*OBNC_PT(typ_, 757)).base_, 757)).size_;
			}
			else {
				ORS__Mark_("type expected", 14);
			}
		}
		else {
			ORS__Mark_("ident expected", 15);
		}
		Check_(44, "no )", 5);
	}
	while (sym_ == 31) {
		n_ = 0;
		obj_ = bot_;
		while (sym_ == 31) {
			obj0_ = obj_;
			while ((obj0_ != 0) && (OBNC_CMP((*OBNC_PT(obj0_, 767)).name_, 32, ORS__id_, 32) != 0)) {
				obj0_ = (*OBNC_PT(obj0_, 767)).next_;
			}
			if (obj0_ != 0) {
				ORS__Mark_("mult def", 9);
			}
			OBNC_NEW(new_, &ORB__ObjDesc_td, struct ORB__ObjDesc_Heap, OBNC_REGULAR_ALLOC);
			ORS__CopyId_((*OBNC_PT(new_, 769)).name_);
			(*OBNC_PT(new_, 769)).class_ = (unsigned char) 4;
			(*OBNC_PT(new_, 769)).next_ = obj_;
			obj_ = new_;
			OBNC_INC(n_);
			ORS__Get_(&sym_);
			CheckExport_(&(*OBNC_PT(new_, 770)).expo_);
			if ((sym_ != 40) && (sym_ != 41)) {
				ORS__Mark_("comma expected", 15);
			}
			else if (sym_ == 40) {
				ORS__Get_(&sym_);
			}
		}
		Check_(41, "colon expected", 15);
		OBNC_PCT(Type_, 775)(&tp_);
		if (((*OBNC_PT(tp_, 776)).form_ == 12) && ((*OBNC_PT(tp_, 776)).len_ < 0)) {
			ORS__Mark_("dyn array not allowed", 22);
		}
		if ((*OBNC_PT(tp_, 777)).size_ > 1) {
			offset_ = (OBNC_DIV(offset_ + 3, 4)) * 4;
		}
		offset_ = offset_ + (n_ * (*OBNC_PT(tp_, 778)).size_);
		off_ = offset_;
		obj0_ = obj_;
		while (obj0_ != bot_) {
			(*OBNC_PT(obj0_, 779)).type_ = tp_;
			(*OBNC_PT(obj0_, 779)).lev_ = 0;
			off_ = off_ - (*OBNC_PT(tp_, 779)).size_;
			(*OBNC_PT(obj0_, 779)).val_ = off_;
			obj0_ = (*OBNC_PT(obj0_, 779)).next_;
		}
		bot_ = obj_;
		if (sym_ == 52) {
			ORS__Get_(&sym_);
		}
		else if (sym_ != 53) {
			ORS__Mark_(" ; or END", 10);
		}
	}
	(*OBNC_PT(typ_, 783)).form_ = 13;
	(*OBNC_PT(typ_, 783)).dsc_ = bot_;
	(*OBNC_PT(typ_, 783)).size_ = (OBNC_DIV(offset_ + 3, 4)) * 4;
	(*type_) = typ_;
}


static void FPSection_(OBNC_INTEGER *adr_, OBNC_INTEGER *nofpar_)
{
	ORB__Object_ obj_ = 0, first_ = 0;
	ORB__Type_ tp_ = 0;
	OBNC_INTEGER parsize_;
	OBNC_INTEGER cl_;
	int rdo_;

	if (sym_ == 65) {
		ORS__Get_(&sym_);
		cl_ = 3;
	}
	else {
		cl_ = 2;
	}
	IdentList_(cl_, &first_);
	OBNC_PCT(FormalType_, 791)(&tp_, 0);
	rdo_ = 0;
	if ((cl_ == 2) && ((*OBNC_PT(tp_, 792)).form_ >= 12)) {
		cl_ = 3;
		rdo_ = 1;
	}
	if ((((*OBNC_PT(tp_, 793)).form_ == 12) && ((*OBNC_PT(tp_, 793)).len_ < 0)) || ((*OBNC_PT(tp_, 793)).form_ == 13)) {
		parsize_ = 8;
	}
	else {
		parsize_ = 4;
	}
	obj_ = first_;
	while (obj_ != 0) {
		OBNC_INC((*nofpar_));
		(*OBNC_PT(obj_, 799)).class_ = (unsigned char) cl_;
		(*OBNC_PT(obj_, 799)).type_ = tp_;
		(*OBNC_PT(obj_, 799)).rdo_ = rdo_;
		(*OBNC_PT(obj_, 799)).lev_ = level_;
		(*OBNC_PT(obj_, 799)).val_ = (*adr_);
		(*adr_) = (*adr_) + parsize_;
		obj_ = (*OBNC_PT(obj_, 801)).next_;
	}
	if ((*adr_) >= 52) {
		ORS__Mark_("too many parameters", 20);
	}
}


static void ProcedureType_(ORB__Type_ ptype_, OBNC_INTEGER *parblksize_)
{
	ORB__Object_ obj_ = 0;
	OBNC_INTEGER size_;
	OBNC_INTEGER nofpar_;

	(*OBNC_PT(ptype_, 807)).base_ = ORB__noType_;
	size_ = (*parblksize_);
	nofpar_ = 0;
	(*OBNC_PT(ptype_, 807)).dsc_ = 0;
	if (sym_ == 28) {
		ORS__Get_(&sym_);
		if (sym_ == 44) {
			ORS__Get_(&sym_);
		}
		else {
			FPSection_(&size_, &nofpar_);
			while (sym_ == 52) {
				ORS__Get_(&sym_);
				FPSection_(&size_, &nofpar_);
			}
			Check_(44, "no )", 5);
		}
		if (sym_ == 41) {
			ORS__Get_(&sym_);
			if (sym_ == 31) {
				qualident_(&obj_);
				(*OBNC_PT(ptype_, 818)).base_ = (*OBNC_PT(obj_, 818)).type_;
				if (! (((*OBNC_PT(obj_, 819)).class_ == 5) && (OBNC_IN((*OBNC_PT((*OBNC_PT(obj_, 819)).type_, 819)).form_, 0x4FEu)))) {
					ORS__Mark_("illegal function type", 22);
				}
			}
			else {
				ORS__Mark_("type identifier expected", 25);
			}
		}
	}
	(*OBNC_PT(ptype_, 826)).nofpar_ = nofpar_;
	(*parblksize_) = size_;
}


static void FormalType0_(ORB__Type_ *typ_, OBNC_INTEGER dim_)
{
	ORB__Object_ obj_ = 0;
	OBNC_INTEGER dmy_;

	if (sym_ == 31) {
		qualident_(&obj_);
		if ((*OBNC_PT(obj_, 834)).class_ == 5) {
			(*typ_) = (*OBNC_PT(obj_, 834)).type_;
		}
		else {
			ORS__Mark_("not a type", 11);
			(*typ_) = ORB__intType_;
		}
	}
	else if (sym_ == 60) {
		ORS__Get_(&sym_);
		Check_(48, "OF ?", 5);
		if (dim_ >= 1) {
			ORS__Mark_("multi-dimensional open arrays not implemented", 46);
		}
		OBNC_NEW((*typ_), &ORB__TypeDesc_td, struct ORB__TypeDesc_Heap, OBNC_REGULAR_ALLOC);
		(*OBNC_PT((*typ_), 838)).form_ = 12;
		(*OBNC_PT((*typ_), 838)).len_ = -1;
		(*OBNC_PT((*typ_), 838)).size_ = 8;
		OBNC_PCT(FormalType_, 840)(&(*OBNC_PT((*typ_), 839)).base_, (dim_ + 1));
	}
	else if (sym_ == 66) {
		ORS__Get_(&sym_);
		ORB__OpenScope_();
		OBNC_NEW((*typ_), &ORB__TypeDesc_td, struct ORB__TypeDesc_Heap, OBNC_REGULAR_ALLOC);
		(*OBNC_PT((*typ_), 842)).form_ = 10;
		(*OBNC_PT((*typ_), 842)).size_ = 4;
		dmy_ = 0;
		ProcedureType_((*typ_), &dmy_);
		(*OBNC_PT((*typ_), 843)).dsc_ = (*OBNC_PT(ORB__topScope_, 843)).next_;
		ORB__CloseScope_();
	}
	else {
		ORS__Mark_("identifier expected", 20);
		(*typ_) = ORB__noType_;
	}
}


static void CheckRecLevel_(OBNC_INTEGER lev_)
{

	if (lev_ != 0) {
		ORS__Mark_("ptr base must be global", 24);
	}
}


static void Type0_(ORB__Type_ *type_)
{
	OBNC_INTEGER dmy_;
	ORB__Object_ obj_ = 0;
	ORP__PtrBase_ ptbase_ = 0;

	(*type_) = ORB__intType_;
	if ((sym_ != 31) && (sym_ < 60)) {
		ORS__Mark_("not a type", 11);
		do {
			ORS__Get_(&sym_);
		} while (! ((sym_ == 31) || (sym_ >= 60)));
	}
	if (sym_ == 31) {
		qualident_(&obj_);
		if ((*OBNC_PT(obj_, 861)).class_ == 5) {
			if (((*OBNC_PT(obj_, 862)).type_ != 0) && ((*OBNC_PT((*OBNC_PT(obj_, 862)).type_, 862)).form_ != 9)) {
				(*type_) = (*OBNC_PT(obj_, 862)).type_;
			}
		}
		else {
			ORS__Mark_("not a type or undefined", 24);
		}
	}
	else if (sym_ == 60) {
		ORS__Get_(&sym_);
		ArrayType_(&(*type_));
	}
	else if (sym_ == 61) {
		ORS__Get_(&sym_);
		RecordType_(&(*type_));
		Check_(53, "no END", 7);
	}
	else if (sym_ == 62) {
		ORS__Get_(&sym_);
		Check_(50, "no TO", 6);
		OBNC_NEW((*type_), &ORB__TypeDesc_td, struct ORB__TypeDesc_Heap, OBNC_REGULAR_ALLOC);
		(*OBNC_PT((*type_), 870)).form_ = 7;
		(*OBNC_PT((*type_), 870)).size_ = 4;
		(*OBNC_PT((*type_), 870)).base_ = ORB__intType_;
		if (sym_ == 31) {
			obj_ = ORB__thisObj_();
			if (obj_ != 0) {
				if (((*OBNC_PT(obj_, 874)).class_ == 5) && (OBNC_IN((*OBNC_PT((*OBNC_PT(obj_, 874)).type_, 874)).form_, 0x2200u))) {
					CheckRecLevel_((*OBNC_PT(obj_, 875)).lev_);
					(*OBNC_PT((*type_), 875)).base_ = (*OBNC_PT(obj_, 876)).type_;
				}
				else if ((*OBNC_PT(obj_, 876)).class_ == 8) {
					ORS__Mark_("external base type not implemented", 35);
				}
				else {
					ORS__Mark_("no valid base type", 19);
				}
			}
			else {
				CheckRecLevel_(level_);
				OBNC_NEW(ptbase_, &ORP__PtrBaseDesc_td, struct ORP__PtrBaseDesc_Heap, OBNC_REGULAR_ALLOC);
				ORS__CopyId_((*OBNC_PT(ptbase_, 880)).name_);
				(*OBNC_PT(ptbase_, 880)).type_ = (*type_);
				(*OBNC_PT(ptbase_, 880)).next_ = pbsList_;
				pbsList_ = ptbase_;
			}
			ORS__Get_(&sym_);
		}
		else {
			OBNC_PCT(Type_, 883)(&(*OBNC_PT((*type_), 883)).base_);
			if (((*OBNC_PT((*OBNC_PT((*type_), 884)).base_, 884)).form_ != 13) || ((*OBNC_PT((*OBNC_PT((*type_), 884)).base_, 884)).typobj_ == 0)) {
				ORS__Mark_("must point to named record", 27);
			}
			CheckRecLevel_(level_);
		}
	}
	else if (sym_ == 66) {
		ORS__Get_(&sym_);
		ORB__OpenScope_();
		OBNC_NEW((*type_), &ORB__TypeDesc_td, struct ORB__TypeDesc_Heap, OBNC_REGULAR_ALLOC);
		(*OBNC_PT((*type_), 889)).form_ = 10;
		(*OBNC_PT((*type_), 889)).size_ = 4;
		dmy_ = 0;
		ProcedureType_((*type_), &dmy_);
		(*OBNC_PT((*type_), 890)).dsc_ = (*OBNC_PT(ORB__topScope_, 890)).next_;
		ORB__CloseScope_();
	}
	else {
		ORS__Mark_("illegal type", 13);
	}
}


static void Declarations_(OBNC_INTEGER *varsize_, OBNC_INTEGER parblksize_)
{
	ORB__Object_ obj_ = 0, first_ = 0;
	ORG__Item_ x_ = {0};
	ORB__Type_ tp_ = 0;
	ORP__PtrBase_ ptbase_ = 0;
	int expo_;
	ORS__Ident_ id_;

	pbsList_ = 0;
	if (((sym_ < 63) && (sym_ != 53)) && (sym_ != 58)) {
		ORS__Mark_("declaration?", 13);
		do {
			ORS__Get_(&sym_);
		} while (! (((sym_ >= 63) || (sym_ == 53)) || (sym_ == 58)));
	}
	if (sym_ == 63) {
		ORS__Get_(&sym_);
		while (sym_ == 31) {
			ORS__CopyId_(id_);
			ORS__Get_(&sym_);
			CheckExport_(&expo_);
			if (sym_ == 9) {
				ORS__Get_(&sym_);
			}
			else {
				ORS__Mark_("= ?", 4);
			}
			OBNC_PCT(expression_, 908)(&x_, &ORG__Item_td);
			if (((*OBNC_PT(x_.type_, 909)).form_ == 11) && (x_.b_ == 2)) {
				ORG__StrToChar_(&x_, &ORG__Item_td);
			}
			ORB__NewObj_(&obj_, id_, 1);
			(*OBNC_PT(obj_, 910)).expo_ = expo_;
			if (x_.mode_ == 1) {
				(*OBNC_PT(obj_, 911)).val_ = x_.a_;
				(*OBNC_PT(obj_, 911)).lev_ = x_.b_;
				(*OBNC_PT(obj_, 911)).type_ = x_.type_;
			}
			else {
				ORS__Mark_("expression not constant", 24);
				(*OBNC_PT(obj_, 912)).type_ = ORB__intType_;
			}
			Check_(52, "; missing", 10);
		}
	}
	if (sym_ == 64) {
		ORS__Get_(&sym_);
		while (sym_ == 31) {
			ORS__CopyId_(id_);
			ORS__Get_(&sym_);
			CheckExport_(&expo_);
			if (sym_ == 9) {
				ORS__Get_(&sym_);
			}
			else {
				ORS__Mark_("=?", 3);
			}
			OBNC_PCT(Type_, 922)(&tp_);
			ORB__NewObj_(&obj_, id_, 5);
			(*OBNC_PT(obj_, 923)).type_ = tp_;
			(*OBNC_PT(obj_, 923)).expo_ = expo_;
			(*OBNC_PT(obj_, 923)).lev_ = level_;
			if ((*OBNC_PT(tp_, 924)).typobj_ == 0) {
				(*OBNC_PT(tp_, 924)).typobj_ = obj_;
			}
			if (expo_ && ((*OBNC_PT((*OBNC_PT(obj_, 925)).type_, 925)).form_ == 13)) {
				(*OBNC_PT(obj_, 925)).exno_ = (unsigned char) exno_;
				OBNC_INC(exno_);
			}
			else {
				(*OBNC_PT(obj_, 925)).exno_ = (unsigned char) 0;
			}
			if ((*OBNC_PT(tp_, 926)).form_ == 13) {
				ptbase_ = pbsList_;
				while (ptbase_ != 0) {
					if (OBNC_CMP((*OBNC_PT(obj_, 929)).name_, 32, (*OBNC_PT(ptbase_, 929)).name_, 32) == 0) {
						(*OBNC_PT((*OBNC_PT(ptbase_, 929)).type_, 929)).base_ = (*OBNC_PT(obj_, 929)).type_;
					}
					ptbase_ = (*OBNC_PT(ptbase_, 931)).next_;
				}
				if (level_ == 0) {
					ORG__BuildTD_(tp_, &dc_);
				}
			}
			Check_(52, "; missing", 10);
		}
	}
	if (sym_ == 65) {
		ORS__Get_(&sym_);
		while (sym_ == 31) {
			IdentList_(2, &first_);
			OBNC_PCT(Type_, 940)(&tp_);
			obj_ = first_;
			while (obj_ != 0) {
				(*OBNC_PT(obj_, 943)).type_ = tp_;
				(*OBNC_PT(obj_, 943)).lev_ = level_;
				if ((*OBNC_PT(tp_, 944)).size_ > 1) {
					(*varsize_) = (OBNC_DIV((*varsize_) + 3, 4)) * 4;
				}
				(*OBNC_PT(obj_, 945)).val_ = (*varsize_) + parblksize_;
				(*varsize_) = (*varsize_) + (*OBNC_PT((*OBNC_PT(obj_, 945)).type_, 945)).size_;
				if ((*OBNC_PT(obj_, 946)).expo_) {
					(*OBNC_PT(obj_, 946)).exno_ = (unsigned char) exno_;
					OBNC_INC(exno_);
				}
				obj_ = (*OBNC_PT(obj_, 948)).next_;
			}
			Check_(52, "; missing", 10);
		}
	}
	(*varsize_) = (OBNC_DIV((*varsize_) + 3, 4)) * 4;
	ptbase_ = pbsList_;
	while (ptbase_ != 0) {
		if ((*OBNC_PT((*OBNC_PT((*OBNC_PT(ptbase_, 955)).type_, 955)).base_, 955)).form_ == 4) {
			ORS__Mark_("undefined pointer base of", 26);
		}
		ptbase_ = (*OBNC_PT(ptbase_, 957)).next_;
	}
	if ((sym_ >= 63) && (sym_ <= 65)) {
		ORS__Mark_("declaration in bad order", 25);
	}
}


static void ProcedureDecl_(void)
{
	ORB__Object_ proc_ = 0;
	ORB__Type_ type_ = 0;
	ORS__Ident_ procid_;
	ORG__Item_ x_ = {0};
	OBNC_INTEGER locblksize_, parblksize_, prevframe_;
	int int_;

	int_ = 0;
	ORS__Get_(&sym_);
	if (sym_ == 1) {
		ORS__Get_(&sym_);
		int_ = 1;
	}
	if (sym_ == 31) {
		ORS__CopyId_(procid_);
		ORS__Get_(&sym_);
		Out__String_(procid_, 32);
		Out__Ln_();
		ORB__NewObj_(&proc_, ORS__id_, 1);
		if (int_) {
			parblksize_ = 12;
		}
		else {
			parblksize_ = 4;
		}
		OBNC_NEW(type_, &ORB__TypeDesc_td, struct ORB__TypeDesc_Heap, OBNC_REGULAR_ALLOC);
		(*OBNC_PT(type_, 974)).form_ = 10;
		(*OBNC_PT(type_, 974)).size_ = 4;
		(*OBNC_PT(proc_, 975)).type_ = type_;
		(*OBNC_PT(proc_, 975)).val_ = -1;
		(*OBNC_PT(proc_, 975)).lev_ = level_;
		CheckExport_(&(*OBNC_PT(proc_, 976)).expo_);
		if ((*OBNC_PT(proc_, 977)).expo_) {
			(*OBNC_PT(proc_, 977)).exno_ = (unsigned char) exno_;
			OBNC_INC(exno_);
		}
		ORB__OpenScope_();
		OBNC_INC(level_);
		(*OBNC_PT(type_, 978)).base_ = ORB__noType_;
		ProcedureType_(type_, &parblksize_);
		Check_(52, "no ;", 5);
		locblksize_ = 0;
		Declarations_(&locblksize_, parblksize_);
		(*OBNC_PT(proc_, 982)).val_ = ORG__pcbytes_;
		(*OBNC_PT((*OBNC_PT(proc_, 982)).type_, 982)).dsc_ = (*OBNC_PT(ORB__topScope_, 982)).next_;
		if (sym_ == 66) {
			do {
				ProcedureDecl_();
				Check_(52, "no ;", 5);
			} while (! (sym_ != 66));
			(*OBNC_PT(proc_, 985)).val_ = ORG__pcbytes_;
			(*OBNC_PT((*OBNC_PT(proc_, 985)).type_, 985)).dsc_ = (*OBNC_PT(ORB__topScope_, 986)).next_;
		}
		ORG__Enter_(parblksize_, locblksize_, &prevframe_);
		if (sym_ == 67) {
			ORS__Get_(&sym_);
			Out__Ln_();
			StatSequence_();
			Out__Ln_();
		}
		if (sym_ == 58) {
			ORS__Get_(&sym_);
			OBNC_PCT(expression_, 990)(&x_, &ORG__Item_td);
			if ((*OBNC_PT(type_, 991)).base_ == ORB__noType_) {
				ORS__Mark_("this is not a function", 23);
			}
			else if (! CompTypes_((*OBNC_PT(type_, 992)).base_, x_.type_, 0)) {
				ORS__Mark_("wrong result type", 18);
			}
		}
		else if ((*OBNC_PT((*OBNC_PT(type_, 994)).base_, 994)).form_ != 9) {
			ORS__Mark_("function without result", 24);
			(*OBNC_PT(type_, 995)).base_ = ORB__noType_;
		}
		ORG__Return_((*OBNC_PT((*OBNC_PT(type_, 997)).base_, 997)).form_, &x_, &ORG__Item_td, locblksize_, prevframe_);
		ORB__CloseScope_();
		OBNC_DEC(level_);
		Check_(53, "no END", 7);
		if (sym_ == 31) {
			if (OBNC_CMP(ORS__id_, 32, procid_, 32) != 0) {
				ORS__Mark_("no match", 9);
			}
			ORS__Get_(&sym_);
		}
		else {
			ORS__Mark_("no proc id", 11);
		}
		Out__String_("END OF ", 8);
		Out__String_(procid_, 32);
		Out__Ln_();
	}
	else {
		ORS__Mark_("proc id expected", 17);
	}
}


static void Import_(void)
{
	ORS__Ident_ impid_, impid1_;

	if (sym_ == 31) {
		ORS__CopyId_(impid_);
		ORS__Get_(&sym_);
		if (sym_ == 42) {
			ORS__Get_(&sym_);
			if (sym_ == 31) {
				ORS__CopyId_(impid1_);
				ORS__Get_(&sym_);
			}
			else {
				ORS__Mark_("id expected", 12);
				OBNC_COPY_ARRAY(impid_, impid1_, 32);
			}
		}
		else {
			OBNC_COPY_ARRAY(impid_, impid1_, 32);
		}
		ORB__Import_(impid_, impid1_);
	}
	else {
		ORS__Mark_("id expected", 12);
	}
}


void ORP__Module_(void)
{
	OBNC_INTEGER key_;

	ORG__Init_();
	Out__Ln_();
	Out__String_("  compiling ", 13);
	ORS__Get_(&sym_);
	if (sym_ == 69) {
		ORS__Get_(&sym_);
		if (sym_ == 1) {
			version_ = 0;
			dc_ = 8;
			Out__String_("*", 2);
			ORS__Get_(&sym_);
		}
		else {
			dc_ = 0;
			version_ = 1;
		}
		ORB__Init_();
		ORB__OpenScope_();
		if (sym_ == 31) {
			ORS__CopyId_(modid_);
			ORS__Get_(&sym_);
			Out__String_(modid_, 32);
			Out__Ln_();
		}
		else {
			ORS__Mark_("identifier expected", 20);
		}
		Check_(52, "no ;", 5);
		level_ = 0;
		exno_ = 1;
		key_ = 0;
		if (sym_ == 68) {
			ORS__Get_(&sym_);
			Import_();
			while (sym_ == 40) {
				ORS__Get_(&sym_);
				Import_();
			}
			Check_(52, "; missing", 10);
		}
		ORG__Open_(version_);
		Declarations_(&dc_, 0);
		ORG__SetDataSize_(((OBNC_DIV(dc_ + 3, 4)) * 4));
		while (sym_ == 66) {
			ProcedureDecl_();
			Check_(52, "no ;", 5);
		}
		ORG__Header_();
		if (sym_ == 67) {
			ORS__Get_(&sym_);
			Out__Ln_();
			StatSequence_();
			Out__Ln_();
		}
		Check_(53, "no END", 7);
		if (sym_ == 31) {
			if (OBNC_CMP(ORS__id_, 32, modid_, 32) != 0) {
				ORS__Mark_("no match", 9);
			}
			ORS__Get_(&sym_);
		}
		else {
			ORS__Mark_("identifier missing", 19);
		}
		if (sym_ != 18) {
			ORS__Mark_("period missing", 15);
		}
		if ((ORS__errcnt_ == 0) && (version_ != 0)) {
			newSF_ = 1;
			ORB__Export_(modid_, &newSF_, &key_);
			if (newSF_) {
				Out__String_(" new symbol file", 17);
				Out__Ln_();
			}
		}
		if (ORS__errcnt_ == 0) {
			ORG__Close_(modid_, key_, exno_);
			Out__Int_(ORG__pc_, 6);
			Out__Int_(dc_, 6);
			Out__Hex_(key_);
		}
		else {
			Out__Ln_();
			Out__String_("compilation FAILED", 19);
		}
		Out__Ln_();
		ORB__CloseScope_();
		pbsList_ = 0;
	}
	else {
		ORS__Mark_("must start with MODULE", 23);
	}
}


void ORP__Init(void)
{
	static int initialized = 0;

	if (! initialized) {
		In__Init();
		Out__Init();
		ORS__Init();
		ORB__Init();
		ORG__Init();
		Out__String_("OR Compiler  8.3.2020", 22);
		Out__Ln_();
		OBNC_NEW(dummy_, &ORB__ObjDesc_td, struct ORB__ObjDesc_Heap, OBNC_REGULAR_ALLOC);
		(*OBNC_PT(dummy_, 1128)).class_ = (unsigned char) 2;
		(*OBNC_PT(dummy_, 1128)).type_ = ORB__intType_;
		expression_ = expression0_;
		Type_ = Type0_;
		FormalType_ = FormalType0_;
		initialized = 1;
	}
}
